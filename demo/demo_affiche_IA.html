<!-- ¬© 2025 Edimah SYNESIUS SONGO ‚Äî Tous droits r√©serv√©s. Produit prot√©g√© par le droit d‚Äôauteur. Reproduction, modification ou diffusion interdite sans autorisation √©crite de l‚Äôautrice. -->
<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <title>Assistant Affiche IA - D√©mo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Police -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/colorthief/dist/color-thief.umd.js"></script>

  <style>
    :root {
      --green: #0A7F5A;
      --green-light: #e9f5ef;
      --feather: 16px;
      --top-slope: 10deg;
      --bottom-slope: -10deg;
      --radius: 18px;
      --header-width: 70%;
      --header-depth: 120px;
      --header-chamfer: 85%;
      --logo-scale: 1;
      --footer-depth: 140px;
      --footer-notch: 8%;
      --footer-notch-right: 0%;
      --band-color: #0c8b64;
      --header-shift-x: 0px;
      --header-shift-y: 0px;
      --footer-shift-x: 0px;
      --footer-shift-y: 0px;
      --product-shift-x: 0px;
      --product-shift-y: 0px;
      --product-scale: 1;
      --gommette-shift-x: 0px;
      --gommette-shift-y: 0px;
      --gommette-scale: 1;
      --gommette-width: 150px;
      --gommette-height: 150px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: "Poppins", Arial, sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      align-items: stretch;
    }

    /* PANNEAUX */
    .controls {
      width: 360px;
      background: #fff;
      padding: 15px 15px 20px;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, .05);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .controls-right {
      width: 320px;
      position: sticky;
      top: 20px;
    }

    .controls h2 {
      margin-top: 0;
      color: var(--green);
      font-size: 1.05rem;
    }

    .controls label {
      font-weight: 600;
      font-size: .78rem;
    }

    .range-control {
      display: flex;
      flex-direction: column;
      gap: 3px;
      margin-bottom: 8px;
    }

    .range-control label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: .7rem;
      font-weight: 600;
    }

    .range-control span {
      font-weight: 500;
      font-size: .68rem;
      color: #395247;
    }

    .range-control input[type="range"] {
      width: 100%;
    }

    .controls input[type="text"],
    .controls input[type="file"] {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #e1e1e1;
      border-radius: 6px;
      font-size: .8rem;
      background: #fff;
    }

    .controls button {
      width: 100%;
      background: var(--green);
      color: #fff;
      border: none;
      padding: 9px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: .85rem;
    }

    .controls button.download-btn {
      background: #c62828;
    }

    .controls button.download-btn:hover {
      background: #b71c1c;
    }

    .editor-hint {
      font-size: .75rem;
      color: #4a5b55;
      margin: 2px 0 10px;
      line-height: 1.3;
    }

    .editor-status {
      padding: 8px 10px;
      border: 1px dashed rgba(10, 127, 90, .35);
      border-radius: 8px;
      font-size: .78rem;
      color: #0b4f3a;
      background: #f4faf7;
      margin-bottom: 12px;
      min-height: 36px;
      display: flex;
      align-items: center;
    }

    .style-panel {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .style-panel label {
      font-size: .76rem;
      font-weight: 600;
      color: #34423d;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
    }

    .style-panel select,
    .style-panel input[type="range"],
    .style-panel input[type="color"] {
      width: 100%;
      border: 1px solid #d7e2dc;
      border-radius: 6px;
      padding: 6px 8px;
      font-size: .78rem;
      background: #fff;
    }

    .style-panel input[type="color"] {
      height: 40px;
      padding: 2px;
      cursor: pointer;
    }

    #fontSizeValue {
      font-weight: 500;
      color: #0a7f5a;
      font-size: .75rem;
    }

    .action-card {
      background: #fff;
      border: 1px solid rgba(9, 60, 45, .12);
      border-radius: 12px;
      padding: 16px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      box-shadow: 0 6px 14px rgba(0, 0, 0, .05);
    }

    .action-title {
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: .08em;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #0b4434;
      margin: 0;
    }

    .action-number {
      background: rgba(10, 127, 90, .12);
      color: var(--green);
      width: 32px;
      height: 32px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      font-weight: 700;
    }

    .action-instructions {
      margin: 0;
      font-size: .8rem;
      color: #42534c;
      line-height: 1.4;
    }

    .action-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 12px;
    }

    .band-color-panel {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 14px;
    }

    .band-color-panel label {
      font-size: .78rem;
      font-weight: 600;
      color: #1f3b32;
    }

    .band-color-panel input[type="color"],
    .band-color-panel input[type="range"] {
      width: 100%;
    }

    #bandAlphaValue {
      font-weight: 500;
      color: #0a7f5a;
    }

    .bg-mode {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
    }

    .bg-mode-option {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: .8rem;
      font-weight: 600;
      color: #1d3a31;
    }

    .bg-mode input[type="color"],
    .bg-mode input[type="file"],
    .bg-mode select {
      width: 100%;
      border: 1px solid #d7e2dc;
      border-radius: 6px;
      padding: 6px 8px;
      font-size: .78rem;
      background: #fff;
    }

    .palette-choice {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 8px;
      font-size: .78rem;
      font-weight: 600;
      color: #2f463d;
    }

    .custom-palette-fields {
      display: none;
      gap: 8px;
      margin-top: 6px;
    }

    .custom-palette-fields.is-visible {
      display: flex;
    }

    .custom-palette-fields input[type="color"] {
      flex: 1;
      height: 42px;
    }

    [data-editable] {
      cursor: text;
      outline: 2px solid transparent;
      transition: outline-color .15s ease, background .15s ease;
    }

    [data-editable].is-editing {
      outline-color: rgba(255, 255, 255, .6);
      background: rgba(255, 255, 255, .04);
    }

    .drag-handle-star {
      position: absolute;
      width: 34px;
      height: 34px;
      border-radius: 50%;
      background: rgba(0, 0, 0, .35);
      border: 1px solid rgba(255, 255, 255, .35);
      color: #fff;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      z-index: 30;
      cursor: move;
      pointer-events: auto;
      box-shadow: 0 6px 14px rgba(0, 0, 0, .25);
    }

    .drag-handle-star:focus-visible {
      outline: 2px solid #fff;
      outline-offset: 2px;
    }

    .drag-handle-star.header-star {
      top: 18px;
      right: 18px;
    }

    .drag-handle-star.footer-star {
      bottom: calc(var(--footer-depth) + 10px);
      right: 24px;
    }

    .workspace {
      display: flex;
      gap: 16px;
      align-items: flex-start;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 8px;
    }

    .workspace>.controls,
    .workspace>.controls-right {
      flex: 0 0 320px;
      min-width: 280px;
    }

    .workspace>.preview-container {
      flex: 0 0 640px;
      min-width: 600px;
    }

    .global-actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 8px;
    }

    .global-actions button {
      width: 100%;
      font-size: 1rem;
      padding: 14px;
    }

    .global-actions button.secondary {
      background: #fff;
      color: var(--green);
      border: 1px solid rgba(10, 127, 90, .2);
    }

    .site-footer {
      margin: 32px auto 12px;
      text-align: center;
      font-size: .7rem;
      color: #2f463d;
      letter-spacing: .01em;
      max-width: 960px;
    }

    .context-toolbar {
      position: absolute;
      background: rgba(18, 41, 34, 0.94);
      color: #fff;
      border-radius: 10px;
      padding: 8px 10px;
      display: none;
      gap: 8px;
      align-items: center;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
      font-size: .75rem;
      z-index: 1200;
    }

    .context-toolbar.is-visible {
      display: inline-flex;
    }

    .context-toolbar select,
    .context-toolbar input[type="color"] {
      border: none;
      border-radius: 6px;
      height: 32px;
      font-size: .75rem;
      padding: 0 6px;
    }

    .toolbar-button {
      background: rgba(255, 255, 255, .12);
      border: none;
      color: #fff;
      border-radius: 6px;
      padding: 6px 10px;
      cursor: pointer;
      font-size: .8rem;
    }

    .toolbar-button.active {
      background: rgba(255, 255, 255, .3);
    }

    .context-toolbar .size-controls {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }


    .controls select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #e1e1e1;
      border-radius: 6px;
      font-size: .8rem;
      background: #fff;
    }

    .detourage-panel {
      border: 1px dashed rgba(10, 127, 90, .35);
      border-radius: 10px;
      padding: 10px;
      margin-top: 4px;
      background: #f6faf8;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: .75rem;
    }

    .detourage-panel legend {
      font-weight: 600;
      font-size: .78rem;
      color: var(--green);
    }

    .detourage-modes {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .detourage-modes label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: .74rem;
      font-weight: 500;
      color: #395247;
    }

    .detourage-modes input[type="radio"] {
      accent-color: var(--green);
    }

    .tolerance-control {
      display: none;
      flex-direction: column;
      gap: 4px;
    }

    .tolerance-control.is-visible {
      display: flex;
    }

    .tolerance-control label {
      display: flex;
      justify-content: space-between;
      font-size: .7rem;
      font-weight: 600;
      color: #395247;
    }

    .tolerance-control input[type="range"] {
      width: 100%;
    }

    .detourage-note {
      font-size: .68rem;
      color: #7a8a81;
      margin: 0;
    }

    .model-choice {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 6px;
      border-radius: 8px;
      background: rgba(255, 255, 255, .65);
      border: 1px dashed rgba(10, 127, 90, .18);
      margin-top: 4px;
    }

    .model-choice span {
      display: inline-flex;
      align-items: baseline;
      gap: 6px;
    }

    .model-choice label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: .74rem;
      font-weight: 500;
      color: #395247;
    }

    .model-choice small {
      font-size: .68rem;
      color: #7a8a81;
    }

    .detourage-status {
      margin-top: 6px;
      font-size: .7rem;
      color: #395247;
      display: flex;
      align-items: center;
      gap: 6px;
      min-height: 18px;
    }

    .detourage-status::before {
      content: "üü¢";
      font-size: .7rem;
    }

    .detourage-status.loading::before {
      content: "";
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid rgba(9, 90, 65, .2);
      border-top-color: rgba(9, 90, 65, .8);
      animation: spin 0.8s linear infinite;
    }

    .detourage-status.error::before {
      content: "‚ö†Ô∏è";
      animation: none;
    }

    .bg-style-controls {
      margin-top: 6px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .bg-checkbox {
      font-size: .75rem;
      font-weight: 500;
      color: #395247;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .bg-checkbox input[type="checkbox"] {
      width: auto;
      accent-color: var(--green);
    }

    .bg-random-btn {
      width: auto !important;
      padding: 6px 14px;
      font-size: .75rem !important;
      flex-shrink: 0;
    }

    #bgLayer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      overflow: hidden;
      border-radius: inherit;
      mix-blend-mode: normal;
    }

    #bgLayer svg {
      width: 100%;
      height: 100%;
    }

    .progress {
      width: 100%;
      height: 0.6rem;
      border-radius: 999px;
      overflow: hidden;
      background: #e2e8f0;
      border: none;
      display: block;
    }

    .progress::-webkit-progress-bar {
      background: transparent;
    }

    .progress::-webkit-progress-value {
      background: linear-gradient(90deg, #60a5fa, #2563eb);
      border-radius: 999px;
    }

    .progress::-moz-progress-bar {
      background: linear-gradient(90deg, #60a5fa, #2563eb);
      border-radius: 999px;
    }

    .controls button.secondary {
      background: #fff;
      color: var(--green);
      border: 1px solid rgba(10, 127, 90, .2);
    }

    .control-block {
      background: #f8f8f8;
      border: 1px solid rgba(0, 0, 0, .03);
      border-radius: 8px;
      padding: 6px;
    }

    .control-title {
      font-size: .7rem;
      font-weight: 600;
      margin-bottom: 4px;
      color: #494f4d;
    }

    /* CROIX + ZOOM (robuste via grid-areas) */
    /* PREVIEW */
    .preview-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-width: 620px;
    }

    .affiche {
      width: 600px;
      height: 800px;
      background: radial-gradient(circle at top, #ffffff 0%, var(--green-light) 40%, #d7ece1 100%);
      border-radius: var(--radius);
      position: relative;
      overflow: hidden;
      box-shadow: 0 6px 15px rgba(0, 0, 0, .12);
    }

    /* Bandeau haut */
    /* Bandeau haut arrondi et plus clair */
    .header-left {
      position: absolute;
      top: 0;
      left: 0;
      background:
        linear-gradient(120deg,
          rgba(255, 255, 255, .15),
          rgba(255, 255, 255, 0) 65%),
        var(--band-color, #0c8b64);
      color: #fff;
      width: clamp(45%, var(--header-width), 95%);
      min-height: clamp(90px, var(--header-depth), 280px);
      padding: clamp(12px, calc(var(--header-depth) * 0.15), 32px) 18px clamp(18px, calc(var(--header-depth) * 0.35), 48px) 22px;
      border-bottom-right-radius: 38px 42px;
      -webkit-clip-path: polygon(0 0, 100% 0, var(--header-chamfer, 85%) 100%, 0 100%);
      clip-path: polygon(0 0, 100% 0, var(--header-chamfer, 85%) 100%, 0 100%);
      z-index: 12;
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.08);
      transition: width .2s ease, min-height .2s ease, padding .2s ease, transform .2s ease;
      transform: translate(var(--header-shift-x, 0px), var(--header-shift-y, 0px));
    }

    .header-left::after {
      content: "";
      position: absolute;
      inset: -18px;
      background:
        linear-gradient(110deg,
          rgba(255, 255, 255, .35) 6%,
          rgba(255, 255, 255, .15) 20%,
          rgba(255, 255, 255, 0) 40%);
      -webkit-clip-path: polygon(0 0, 100% 0, var(--header-chamfer, 85%) 100%, 0 100%);
      clip-path: polygon(0 0, 100% 0, var(--header-chamfer, 85%) 100%, 0 100%);
      filter: blur(18px);
      opacity: .75;
      z-index: -1;
      pointer-events: none;
    }

    @supports (clip-path: path('M0 0')) {
      .header-left {
        -webkit-clip-path: path("M0 0 H 100% L 100% 78% Q 100% 100% 82% 100% L 85% 100% L 0 100% Z");
        clip-path: path("M0 0 H 100% L 100% 78% Q 100% 100% 82% 100% L 85% 100% L 0 100% Z");
      }

      .header-left::after {
        -webkit-clip-path: path("M0 0 H 100% L 100% 78% Q 100% 100% 82% 100% L 85% 100% L 0 100% Z");
        clip-path: path("M0 0 H 100% L 100% 78% Q 100% 100% 82% 100% L 85% 100% L 0 100% Z");
      }
    }

    .header-left .promo-title {
      font-size: 1.05rem;
      font-weight: 700;
      margin: 0;
    }

    .header-left .promo-date {
      font-size: .7rem;
      margin: 4px 0 0;
      opacity: .92;
    }

    /* LOGO */
    .logo {
      position: absolute;
      top: 18px;
      right: 18px;
      width: calc(110px * var(--logo-scale));
      height: calc(60px * var(--logo-scale));
      background: transparent;
      border-radius: 14px;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      border: none;
      z-index: 40;
      transform: translate(var(--logo-shift-x, 0px), var(--logo-shift-y, 0px)) scale(var(--logo-scale, 1));
      transition: transform .25s ease;
      touch-action: none;
      cursor: grab;
      user-select: none;
      isolation: isolate;
      transform-origin: center center;
    }

    .logo img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .logo .placeholder {
      font-size: .65rem;
      color: rgba(0, 0, 0, .4);
      text-align: center;
      background: rgba(255, 255, 255, .25);
      padding: 4px 6px;
      border-radius: 8px;
    }

    /* GOMMETTE */
    .gommette {
      position: absolute;
      top: 120px;
      right: 35px;
      width: var(--gommette-width, 150px);
      height: var(--gommette-height, 150px);
      background: radial-gradient(circle, #ff9a7a 0%, #ff7b5a 45%, #ff5c32 100%);
      border-radius: 50%;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-weight: 700;
      font-size: 1.3rem;
      letter-spacing: .01em;
      box-shadow: 0 8px 18px rgba(255, 123, 90, .42);
      z-index: 13;
      isolation: isolate;
      transform-origin: center center;
      transform: translate(var(--gommette-shift-x, 0px), var(--gommette-shift-y, 0px)) scale(var(--gommette-scale, 1));
      touch-action: none;
      cursor: grab;
      user-select: none;
    }

    .gommette::after {
      content: "";
      position: absolute;
      inset: -18px;
      background: radial-gradient(circle, rgba(255, 123, 90, .35) 0%, rgba(255, 123, 90, 0) 70%);
      filter: blur(12px);
      z-index: -1;
      pointer-events: none;
    }

    /* PRODUIT */
    .product-image {
      position: absolute;
      top: 235px;
      left: 50%;
      transform: translateX(-50%) translate(var(--product-shift-x, 0px), var(--product-shift-y, 0px)) scale(var(--product-scale, 1));
      width: 360px;
      height: 280px;
      background: transparent;
      border: none;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      z-index: 11;
      transform-origin: center center;
      isolation: isolate;
      transition: .25s ease;
      touch-action: none;
      cursor: grab;
      user-select: none;
    }

    .product-image::after {
      content: "";
      position: absolute;
      inset: -28px;
      background: radial-gradient(circle,
          rgba(255, 255, 255, .85) 0%,
          rgba(255, 255, 255, .28) 55%,
          rgba(255, 255, 255, 0) 80%);
      filter: blur(18px);
      opacity: 0;
      transform: scale(.9);
      transition: .25s ease;
      pointer-events: none;
      z-index: -1;
    }

    .product-image.has-image::after {
      opacity: .8;
      transform: scale(1);
    }

    .product-image img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      background: transparent;
      position: relative;
      z-index: 1;
      transition: .25s ease;
      pointer-events: none;
    }

    .product-image.has-image img {
      filter: drop-shadow(0 12px 24px rgba(10, 127, 90, .25));
    }

    .product-image.dragging,
    .gommette.dragging,
    .logo.dragging {
      cursor: grabbing;
    }

    .product-placeholder {
      color: rgba(10, 127, 90, .5);
      text-align: center;
      font-size: .85rem;
      opacity: .6;
      background: rgba(255, 255, 255, .25);
      padding: 8px 10px;
      border-radius: 999px;
      pointer-events: none;
    }

    /* bulles d√©coratives */
    .bubble {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, .22);
      pointer-events: none;
      z-index: 0;
      box-shadow: 0 3px 8px rgba(10, 127, 90, .08);
      border: 1px solid rgba(255, 255, 255, .22);
      filter: blur(.2px);
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Bandeau bas */
    .footer-band {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      min-height: clamp(90px, var(--footer-depth), 320px);
      background:
        linear-gradient(120deg,
          rgba(255, 255, 255, .12) 0%,
          rgba(0, 0, 0, .08) 60%,
          rgba(0, 0, 0, 0) 100%),
        var(--band-color, #0A7F5A);
      color: #fff;
      padding: clamp(14px, calc(var(--footer-depth) * 0.25), 38px) 24px clamp(20px, calc(var(--footer-depth) * 0.45), 58px);
      display: flex;
      flex-direction: column;
      gap: 6px;
      border-radius: 36px;
      overflow: hidden;
      -webkit-clip-path: polygon(0% calc(var(--footer-notch) + var(--footer-corner-y)),
          var(--footer-corner-x) var(--footer-notch),
          calc(100% - var(--footer-corner-x)) var(--footer-notch-right, 0%),
          100% calc(var(--footer-notch-right, 0%) + var(--footer-corner-y)),
          100% calc(100% - var(--footer-corner-y)),
          calc(100% - var(--footer-corner-x)) 100%,
          var(--footer-corner-x) 100%,
          0% calc(100% - var(--footer-corner-y)));
      clip-path: polygon(0% calc(var(--footer-notch) + var(--footer-corner-y)),
          var(--footer-corner-x) var(--footer-notch),
          calc(100% - var(--footer-corner-x)) var(--footer-notch-right, 0%),
          100% calc(var(--footer-notch-right, 0%) + var(--footer-corner-y)),
          100% calc(100% - var(--footer-corner-y)),
          calc(100% - var(--footer-corner-x)) 100%,
          var(--footer-corner-x) 100%,
          0% calc(100% - var(--footer-corner-y)));
      transition: .2s ease;
      backdrop-filter: blur(1px);
      isolation: isolate;
      z-index: 12;
      transform: translate(var(--footer-shift-x, 0px), var(--footer-shift-y, 0px));
    }

    .footer-band::before {
      content: "";
      position: absolute;
      inset: -24px;
      background:
        linear-gradient(120deg,
          rgba(255, 255, 255, .25) 0%,
          rgba(255, 255, 255, .05) 55%,
          rgba(255, 255, 255, 0) 100%);
      -webkit-clip-path: polygon(0% calc(var(--footer-notch) + var(--footer-corner-y)),
          var(--footer-corner-x) var(--footer-notch),
          calc(100% - var(--footer-corner-x)) var(--footer-notch-right, 0%),
          100% calc(var(--footer-notch-right, 0%) + var(--footer-corner-y)),
          100% calc(100% - var(--footer-corner-y)),
          calc(100% - var(--footer-corner-x)) 100%,
          var(--footer-corner-x) 100%,
          0% calc(100% - var(--footer-corner-y)));
      clip-path: polygon(0% calc(var(--footer-notch) + var(--footer-corner-y)),
          var(--footer-corner-x) var(--footer-notch),
          calc(100% - var(--footer-corner-x)) var(--footer-notch-right, 0%),
          100% calc(var(--footer-notch-right, 0%) + var(--footer-corner-y)),
          100% calc(100% - var(--footer-corner-y)),
          calc(100% - var(--footer-corner-x)) 100%,
          var(--footer-corner-x) 100%,
          0% calc(100% - var(--footer-corner-y)));
      filter: blur(26px);
      opacity: .8;
      pointer-events: none;
      z-index: -1;
    }

    .footer-title {
      font-size: 1.25rem;
      font-weight: 700;
    }

    .footer-subtitle {
      font-size: .78rem;
      opacity: .85;
    }
  </style>
</head>

<body>

  <div class="workspace">
    <!-- COLONNE GAUCHE -->
    <div class="controls">
      <div class="action-card">
        <h2 class="action-title"><span class="action-number">1.</span>Importer le logo</h2>
        <input id="logoInput" type="file" accept="image/*" />
        <p class="action-instructions">Taille et emplacement ajustables directement sur l'affiche.
        </p>
      </div>

      <div class="action-card">
        <h2 class="action-title"><span class="action-number">2.</span>Importer une photo du produit</h2>
        <p class="action-instructions">Photo <b><u>centr√©e</u></b>, soit prise </p>
        <ul class="action-instructions">
          <li><i>depuis votre appareil</i> üì∏</li>
          <li><i>sur internet </i> üåê</li>
        </ul>
        <input id="productInput" type="file" accept="image/*" />
        <p class="action-instructions"><b>L'IA retire automatiquement l'arri√®re-plan de la photo.</b></p>
        <fieldset class="detourage-panel">
          <legend>ü™Ñ Param√®tres de d√©tourage par IA</legend>
          <div class="detourage-modes">
            <label><input type="radio" name="detourageMode" value="auto" checked />Auto (recommand√©)</label>
            <label><input type="radio" name="detourageMode" value="ia" />Forcer IA (U¬≤-Net)</label>
            <label><input type="radio" name="detourageMode" value="color" />Forcer d√©tourage sans IA</label>
          </div>
          <div class="tolerance-control" id="toleranceControl">
            <label for="toleranceRange">Tol√©rance <span id="toleranceValue">40</span></label>
            <input type="range" id="toleranceRange" min="0" max="60" value="40" />
          </div>
          <div class="model-choice" style="color:DodgerBlue;">
            <span>Mod√®le d'IA utilis√©</span>
            <label>
              <input type="radio" name="u2netModel" value="u2netp.onnx" checked />
              <span>fond uni <small>(u2netp.onnx)</small></span>
            </label>
            <label>
              <input type="radio" name="u2netModel" value="u2net.onnx" />
              <span>fond encombr√© <small>(u2net.onnx)</small></span>
            </label>
          </div>
          <p class="detourage-note">Les images restent sur votre appareil.</p>
        </fieldset>
        <div class="detourage-status" id="detourageStatus">Initialisation de l'IA‚Ä¶</div>
        <progress id="detourageProgress" class="progress" max="100" value="0" hidden></progress>
      </div>

      <div class="action-card">
        <div class="global-actions">
          <button type="button" id="updatePosterBtn">Mettre √† jour l'affiche</button>
          <button type="button" id="resetPosterBtn" class="secondary">R√©initialiser l'affiche</button>
          <button type="button" id="downloadPosterBtn" class="download-btn">T√©l√©charger l'affiche</button>
        </div>
      </div>
    </div>

    <!-- PREVIEW CENTRE -->
    <!-- PREVIEW CENTRE -->
    <div class="preview-container">
      <div class="affiche" id="affiche">
        <div id="bgLayer"></div>
        <div class="header-left">
          <p class="promo-title" id="afficheTitle" data-editable="header-title" data-label="Titre promo"
            contenteditable="true" spellcheck="false">Promo d'automne - Vitamine D</p>
          <p class="promo-date" id="afficheDate" data-editable="header-date" data-label="Date/accroche"
            contenteditable="true" spellcheck="false">Du 1er au 15 novembre</p>
        </div>
        <button type="button" class="drag-handle-star header-star" id="headerDragHandle"
          aria-label="D√©placer le texte du bandeau haut">‚ú∂</button>

        <div class="logo" id="afficheLogo"><span class="placeholder">logo</span></div>
        <div class="gommette" id="afficheBadge"><span id="afficheBadgeText" data-editable="badge"
            data-label="Texte gommette" contenteditable="true" spellcheck="false">-20%</span></div>
        <div class="product-image" id="afficheProduct">
          <div class="product-placeholder">Photo du produit<br />ici</div>
        </div>

        <div class="footer-band">
          <div class="footer-title" id="afficheProductName" data-editable="footer-title" data-label="Titre bas"
            contenteditable="true" spellcheck="false">Vitamine D3 Senior 1000 UI</div>
          <div class="footer-subtitle" id="afficheProductSubtitle" data-editable="footer-subtitle"
            data-label="Sous-titre bas" contenteditable="true" spellcheck="false">Demandez conseil √† votre pharmacien
          </div>
        </div>
        <button type="button" class="drag-handle-star footer-star" id="footerDragHandle"
          aria-label="D√©placer le texte du bandeau bas">‚ú∂</button>
      </div>
    </div>

    <!-- PANNEAU DROIT : Cr√©ation & Contr√¥les -->
    <div class="controls controls-right">
      <div class="action-card">
        <h2 class="action-title"><span class="action-number">3.</span>Modifier le texte</h2>
        <p class="action-instructions">Cliquez directement sur les zones de texte de l'affiche pour les modifier puis
          ajustez-les via la barre contextuelle qui appara√Æt juste en dessous.</p>
        <div class="editor-status" id="editorStatus">S√©lectionnez un bloc de texte pour afficher la r√©glette
          contextuelle.</div>
      </div>

      <div class="action-card">
        <h2 class="action-title"><span class="action-number">4.</span>Modifier les couleurs</h2>
        <p class="action-instructions">Choisissez un type d'arri√®re-plan puis ajustez le d√©grad√© et la couleur des
          bandeaux.</p>

        <div class="bg-mode">
          <label class="bg-mode-option"><input type="radio" name="bgMode" value="solid" />Couleur unie</label>
          <input type="color" id="solidBgColor" value="#eaf7f1" />

          <label class="bg-mode-option"><input type="radio" name="bgMode" value="image" />Image mod√®le</label>
          <input type="file" id="bgImageInput" accept="image/*" />
          <button type="button" id="bgImageClearBtn" class="secondary" disabled>Retirer l'image</button>

          <label class="bg-mode-option"><input type="radio" name="bgMode" value="generated" checked />Fond
            g√©n√©r√©</label>
          <select id="bgStyleSelect">
            <option value="bubbles">Bulles</option>
            <option value="waves">Ondes</option>
            <option value="dots">Pointill√©</option>
            <option value="cross">Motif croix</option>
          </select>

          <div class="palette-choice">
            <label><input type="radio" name="bgPaletteMode" value="logo" checked />Palette du logo</label>
            <label><input type="radio" name="bgPaletteMode" value="custom" />D√©grad√© personnalis√©</label>
          </div>
          <div class="custom-palette-fields" id="customPaletteFields">
            <input type="color" id="customColorA" value="#0A7F5A" />
            <input type="color" id="customColorB" value="#A4D4AE" />
          </div>
          <button type="button" id="bgRandomBtn" class="secondary">Al√©atoire</button>
        </div>

      </div>
    </div>

  </div>
  </div>

  <div id="contextToolbar" class="context-toolbar">
    <div id="bandToolbar" class="toolbar-section">
      <label for="toolbarBandColor" style="margin:0;font-size:.7rem;">Bandeaux</label>
      <input type="color" id="toolbarBandColor" value="#0a7f5a" />
      <input type="range" id="toolbarBandOpacity" min="0" max="100" value="95" />
      <span id="toolbarBandOpacityValue">95%</span>
    </div>
    <div id="textToolbar" class="toolbar-section">
      <select id="toolbarFontSelect">
        <option value="Poppins">Poppins</option>
        <option value="Playfair Display">Playfair Display</option>
        <option value="Montserrat">Montserrat</option>
        <option value="Source Serif Pro">Source Serif Pro</option>
        <option value="Raleway">Raleway</option>
      </select>
      <div class="size-controls">
        <button type="button" class="toolbar-button" data-size="minus">‚àí</button>
        <button type="button" class="toolbar-button" data-size="plus">+</button>
      </div>
      <input type="color" id="toolbarTextColor" value="#0a7f5a" />
    </div>
  </div>

  <!-- SCRIPTS -->
  <!-- SCRIPTS -->
  <script type="module">
    // --- Constantes & chemins dynamiques ---
    const DETOUR_MODE = Object.freeze({ AUTO: 'auto', IA: 'ia', COLOR: 'color' });
    const DEFAULT_MODEL_CHOICE = 'u2netp.onnx';
    const U2NET_RELEASE_URL = 'https://huggingface.co/edimah/u2net/resolve/main/u2net.onnx';
    const resolveAssetUrl = (relativePath) => new URL(relativePath, import.meta.url).href;
    const MODULE_PATH = resolveAssetUrl('../assets/js/bgremoval.mjs');
    let modelChoice = DEFAULT_MODEL_CHOICE;
    const MODEL_URLS = {
      'u2netp.onnx': resolveAssetUrl('../models/u2netp.onnx'),
      'u2net.onnx': U2NET_RELEASE_URL,
    };
    const MODEL_LABELS = {
      'u2netp.onnx': 'U¬≤-Net (fond uni)',
      'u2net.onnx': 'U¬≤-Net (images encombr√©es)',
    };
    const getModelUrl = () => MODEL_URLS[modelChoice] || MODEL_URLS[DEFAULT_MODEL_CHOICE];
    const getModelLabel = () => MODEL_LABELS[modelChoice] || modelChoice;

    // --- R√©f√©rences DOM ---
    const logoInput = document.getElementById('logoInput');
    const productInput = document.getElementById('productInput');
    const detourageStatusEl = document.getElementById('detourageStatus');
    const detourProgress = document.getElementById('detourageProgress');
    const toleranceRange = document.getElementById('toleranceRange');
    const toleranceValue = document.getElementById('toleranceValue');
    const toleranceContainer = document.getElementById('toleranceControl');
    const detourageModeInputs = document.querySelectorAll('input[name="detourageMode"]');
    const modelChoiceInputs = document.querySelectorAll('input[name="u2netModel"]');

    const affiche = document.getElementById('affiche');
    const afficheTitle = document.getElementById('afficheTitle');
    const afficheDate = document.getElementById('afficheDate');
    const afficheBadge = document.getElementById('afficheBadge');
    const afficheBadgeText = document.getElementById('afficheBadgeText');
    const afficheProductName = document.getElementById('afficheProductName');
    const afficheProductSubtitle = document.getElementById('afficheProductSubtitle');
    const afficheLogo = document.getElementById('afficheLogo');
    const afficheProduct = document.getElementById('afficheProduct');
    const bgStyleSelect = document.getElementById('bgStyleSelect');
    const bgRandomBtn = document.getElementById('bgRandomBtn');
    const bgLayer = document.getElementById('bgLayer');
    const updatePosterBtn = document.getElementById('updatePosterBtn');
    const resetPosterBtn = document.getElementById('resetPosterBtn');
    const downloadPosterBtn = document.getElementById('downloadPosterBtn');
    const bgModeInputs = document.querySelectorAll('input[name="bgMode"]');
    const solidBgColorInput = document.getElementById('solidBgColor');
    const bgImageInput = document.getElementById('bgImageInput');
    const bgImageClearBtn = document.getElementById('bgImageClearBtn');
    const paletteModeInputs = document.querySelectorAll('input[name="bgPaletteMode"]');
    const customPaletteFields = document.getElementById('customPaletteFields');
    const customColorAInput = document.getElementById('customColorA');
    const customColorBInput = document.getElementById('customColorB');
    const editorStatus = document.getElementById('editorStatus');
    const editableElements = document.querySelectorAll('[data-editable]');
    const headerDragHandle = document.getElementById('headerDragHandle');
    const footerDragHandle = document.getElementById('footerDragHandle');
    const headerBlock = document.querySelector('.header-left');
    const footerBlock = document.querySelector('.footer-band');
    const contextToolbar = document.getElementById('contextToolbar');
    const bandToolbar = document.getElementById('bandToolbar');
    const textToolbar = document.getElementById('textToolbar');
    const toolbarBandColor = document.getElementById('toolbarBandColor');
    const toolbarBandOpacity = document.getElementById('toolbarBandOpacity');
    const toolbarBandOpacityValue = document.getElementById('toolbarBandOpacityValue');
    const toolbarFontSelect = document.getElementById('toolbarFontSelect');
    const toolbarTextColor = document.getElementById('toolbarTextColor');
    const sizeButtons = document.querySelectorAll('.size-controls .toolbar-button');

    const root = document.documentElement;

    const DEFAULT_COLORS = ['#0A7F5A', '#4EB190', '#9FD7B8'];
    const DEFAULT_CUSTOM_A = '#0A7F5A';
    const DEFAULT_CUSTOM_B = '#A4D4AE';
    const DEFAULT_BAND_COLOR = '#0a7f5a';
    const DEFAULT_TOLERANCE = 40;
    const DEFAULT_SOLID_BG = '#eaf7f1';
    const sampleCanvas = document.createElement('canvas');
    const sampleCtx = sampleCanvas.getContext('2d');
    let brandColors = [];
    let colorThiefInstance = null;
    const DEFAULT_TEXTS = Object.freeze({
      title: "Promo d'automne - Vitamine D",
      date: 'Du 1er au 15 novembre',
      badge: '-20%',
      productName: 'Vitamine D3 Senior 1000 UI',
      productSubtitle: 'Demandez conseil √† votre pharmacien',
    });
    const DEFAULT_PLACEHOLDERS = Object.freeze({
      logo: '<span class="placeholder">logo</span>',
      product: '<div class="product-placeholder">Photo du produit<br />ici</div>',
    });
    const EDGE_TOLERANCE = 26;
    const POSTER_BASE_WIDTH = 600;
    const HEADER_WIDTH_LIMITS = [45, 95];
    const HEADER_DEPTH_LIMITS = [90, 280];
    const HEADER_CHAMFER_LIMITS = [55, 100];
    const FOOTER_DEPTH_LIMITS = [120, 360];
    const FOOTER_NOTCH_LIMITS = [0, 40];
    const GOMMETTE_WIDTH_LIMITS = [90, 280];
    const GOMMETTE_HEIGHT_LIMITS = [90, 280];

    const state = {
      lastLogoImage: null,
      lastProductImage: null,
      lastLogoFile: null,
      lastProductFile: null,
      lastLogoDataURL: null,
      lastLogoMode: null,
      lastProductMode: null,
      logoManualColor: null,
    };

    let currentBgMode = 'solid';
    let currentPaletteMode = 'logo';
    let customPalette = [
      customColorAInput?.value || '#0A7F5A',
      customColorBInput?.value || '#A4D4AE',
    ];
    let bgImageDataURL = null;
    const baseBackground = getComputedStyle(affiche).background;
    let activeToolbarMode = null;
    let activeBandTarget = null;
    let bandDragConfig = null;
    let textDragConfig = null;
    let html2canvasPromise;
    const textOffsets = new WeakMap();
    const bandShiftVars = new Map([
      [headerBlock, { xVar: '--header-shift-x', yVar: '--header-shift-y' }],
      [footerBlock, { xVar: '--footer-shift-x', yVar: '--footer-shift-y' }],
    ]);
    const TEXT_DRAG_LIMITS = { x: [-220, 220], y: [-160, 240] };
    const BAND_DRAG_LIMITS = { x: [-240, 240], y: [-240, 240] };
    const createTextDragState = () => ({
      enabled: false,
      pointerId: null,
      startX: 0,
      startY: 0,
      baseX: 0,
      baseY: 0,
    });
    textDragConfig = createTextDragState();
    bandDragConfig = {
      pointerId: null,
      startX: 0,
      startY: 0,
      baseX: 0,
      baseY: 0,
      target: null,
    };

    const selectedModelInput = document.querySelector('input[name="u2netModel"]:checked');
    if (selectedModelInput?.value) {
      modelChoice = selectedModelInput.value;
    }

    // --- UI helpers ---
    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
    const clamp255 = (value) => clamp(value, 0, 255);
    const clampValue = (value, min, max) => clamp(value, min, max);

    const hexToRgb = (hex) => {
      if (!hex) return { r: 0, g: 0, b: 0 };
      let clean = hex.replace('#', '');
      if (clean.length === 3) {
        clean = clean.split('').map((c) => c + c).join('');
      }
      const intVal = parseInt(clean, 16);
      return {
        r: (intVal >> 16) & 255,
        g: (intVal >> 8) & 255,
        b: intVal & 255,
      };
    };

    const rgbArrayToHex = (arr = []) => {
      const [r = 0, g = 0, b = 0] = arr;
      const toHex = (v) => clamp255(v).toString(16).padStart(2, '0');
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    };

    const adjustColor = (hex, amount = 0) => {
      const { r, g, b } = hexToRgb(hex);
      const adjust = (channel) => clamp255(channel + amount * 255);
      return rgbArrayToHex([adjust(r), adjust(g), adjust(b)]);
    };

    const rgba = (hex, alpha = 1) => {
      const { r, g, b } = hexToRgb(hex);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    const hexToRgba = (hex, alpha = 1) => {
      const { r, g, b } = hexToRgb(hex);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    const randRange = (min, max) => Math.random() * (max - min) + min;

    const getCssVarNumber = (cssVar) => parseFloat(getComputedStyle(root).getPropertyValue(cssVar)) || 0;
    const setCssVarNumber = (cssVar, value, unit = 'px') => {
      root.style.setProperty(cssVar, `${value}${unit}`);
    };

    const clearBackgroundLayer = () => {
      if (!bgLayer) return;
      bgLayer.innerHTML = '';
      bgLayer.style.background = 'none';
      bgLayer.style.backgroundImage = 'none';
      bgLayer.style.backgroundColor = 'transparent';
    };

    const resetTextPositions = () => {
      ['--header-shift-x', '--header-shift-y', '--footer-shift-x', '--footer-shift-y'].forEach((varName) => {
        root.style.setProperty(varName, '0px');
      });
    };

    const enableTextDragMode = (enabled) => {
      if (!enabled) {
        resetTextPositions();
      }
    };

    const manualBandOverrides = new Set();

    const parseCssNumber = (cssVar, fallback = 0) => {
      const value = parseFloat(getComputedStyle(root).getPropertyValue(cssVar));
      return Number.isFinite(value) ? value : fallback;
    };

    const setBandVarManual = (cssVar, value, unit = 'px') => {
      manualBandOverrides.add(cssVar);
      setCssVarNumber(cssVar, value, unit);
    };

    const setBandVarIfUnlocked = (cssVar, value, unit = 'px') => {
      if (manualBandOverrides.has(cssVar)) return;
      setCssVarNumber(cssVar, value, unit);
    };

    const autoAdjustBands = () => {
      const headerText = `${afficheTitle?.textContent || ''} ${afficheDate?.textContent || ''}`.trim();
      const headerChars = Math.max(headerText.length, 12);
      const headerWidth = clampValue(50 + headerChars * 0.4, 50, 95);
      const headerDepth = clampValue(110 + headerChars * 0.45, 90, 240);
      setBandVarIfUnlocked('--header-width', headerWidth, '%');
      setBandVarIfUnlocked('--header-depth', headerDepth, 'px');

      const footerText = `${afficheProductName?.textContent || ''} ${afficheProductSubtitle?.textContent || ''}`.trim();
      const footerChars = Math.max(footerText.length, 18);
      const footerDepth = clampValue(150 + footerChars * 0.3, 120, 300);
      const footerNotch = clampValue(8 + footerChars * 0.04, 4, 18);
      setBandVarIfUnlocked('--footer-depth', footerDepth, 'px');
      setBandVarIfUnlocked('--footer-notch', footerNotch, '%');
    };

    const updateBandColor = () => {
      const colorHex = toolbarBandColor?.value || '#0a7f5a';
      const alpha = clampValue((toolbarBandOpacity?.value || 95) / 100, 0, 1);
      if (toolbarBandOpacityValue) toolbarBandOpacityValue.textContent = `${Math.round(alpha * 100)}%`;
      const rgbaColor = hexToRgba(colorHex, alpha);
      root.style.setProperty('--band-color', rgbaColor);
    };

    const resetDraggableTransforms = () => {
      const defaults = {
        '--header-shift-x': '0px',
        '--header-shift-y': '0px',
        '--footer-shift-x': '0px',
        '--footer-shift-y': '0px',
        '--product-shift-x': '0px',
        '--product-shift-y': '0px',
        '--product-scale': '1',
        '--gommette-shift-x': '0px',
        '--gommette-shift-y': '0px',
        '--gommette-scale': '1',
        '--logo-shift-x': '0px',
        '--logo-shift-y': '0px',
        '--logo-scale': '1',
      };
      Object.entries(defaults).forEach(([varName, value]) => root.style.setProperty(varName, value));
    };

    const restorePlaceholder = (container, html) => {
      if (!container) return;
      container.innerHTML = html;
      container.classList.remove('has-image');
    };

    const resetEditableBlocks = () => {
      const pairs = [
        [afficheTitle, DEFAULT_TEXTS.title],
        [afficheDate, DEFAULT_TEXTS.date],
        [afficheBadgeText, DEFAULT_TEXTS.badge],
        [afficheProductName, DEFAULT_TEXTS.productName],
        [afficheProductSubtitle, DEFAULT_TEXTS.productSubtitle],
      ];
      pairs.forEach(([el, text]) => {
        if (!el) return;
        el.textContent = text;
        el.style.fontFamily = '';
        el.style.fontSize = '';
        el.style.color = '';
        el.style.transform = '';
        textOffsets.delete(el);
      });
    };

    const resetBandControlsToDefault = () => {
      if (toolbarBandColor) toolbarBandColor.value = DEFAULT_BAND_COLOR;
      if (toolbarBandOpacity) toolbarBandOpacity.value = 95;
      if (toolbarBandOpacityValue) toolbarBandOpacityValue.textContent = '95%';
      updateBandColor();
    };

    const resetDetourageControls = () => {
      detourageModeInputs.forEach((input) => {
        input.checked = input.value === DETOUR_MODE.AUTO;
      });
      modelChoiceInputs.forEach((input) => {
        const isDefault = input.value === DEFAULT_MODEL_CHOICE;
        input.checked = isDefault;
        if (isDefault) modelChoice = input.value;
      });
      if (toleranceRange) {
        toleranceRange.value = DEFAULT_TOLERANCE;
        updateToleranceLabel();
      }
      setToleranceVisibility(false);
      setDetourageStatus(`R√©initialis√©. Mod√®le ${getModelLabel()} pr√™t.`, 'idle');
    };

    const resetBackgroundSettings = () => {
      brandColors = [];
      bgImageDataURL = null;
      if (bgImageInput) bgImageInput.value = '';
      bgModeInputs.forEach((input) => {
        input.checked = input.value === 'generated';
      });
      paletteModeInputs.forEach((input) => {
        input.checked = input.value === 'logo';
      });
      if (solidBgColorInput) solidBgColorInput.value = DEFAULT_SOLID_BG;
      if (customColorAInput) customColorAInput.value = DEFAULT_CUSTOM_A;
      if (customColorBInput) customColorBInput.value = DEFAULT_CUSTOM_B;
      currentPaletteMode = 'logo';
      setBackgroundMode('generated', { forceRandom: true });
    };

    const clearMediaState = () => {
      state.lastLogoImage = null;
      state.lastProductImage = null;
      state.lastLogoFile = null;
      state.lastProductFile = null;
      state.lastLogoDataURL = null;
      state.lastProductMode = null;
      state.lastLogoMode = null;
      state.logoManualColor = null;
      logoInput && (logoInput.value = '');
      productInput && (productInput.value = '');
      restorePlaceholder(afficheLogo, DEFAULT_PLACEHOLDERS.logo);
      restorePlaceholder(afficheProduct, DEFAULT_PLACEHOLDERS.product);
      afficheLogo?.classList.remove('dragging');
      afficheProduct?.classList.remove('dragging');
    };

    const resetMorphableShapes = () => {
      manualBandOverrides.clear();
      root.style.setProperty('--header-chamfer', '85%');
      root.style.setProperty('--footer-notch-right', '0%');
      root.style.setProperty('--gommette-width', '150px');
      root.style.setProperty('--gommette-height', '150px');
    };

    const resetPoster = () => {
      clearActiveEditable();
      hideContextToolbar();
      resetMorphableShapes();
      resetEditableBlocks();
      resetDraggableTransforms();
      clearMediaState();
      resetBandControlsToDefault();
      resetBackgroundSettings();
      customPalette = [
        customColorAInput?.value || DEFAULT_CUSTOM_A,
        customColorBInput?.value || DEFAULT_CUSTOM_B,
      ];
      resetDetourageControls();
      if (bgImageClearBtn) bgImageClearBtn.setAttribute('disabled', 'disabled');
      autoAdjustBands();
      syncBackgroundControls();
    };

    const applySolidBackground = () => {
      enableTextDragMode(false);
      if (!affiche) return;
      const color = solidBgColorInput?.value || '#eaf7f1';
      affiche.style.background = color;
      clearBackgroundLayer();
    };

    const applyGeneratedBackground = ({ forceRandom = false } = {}) => {
      enableTextDragMode(false);
      if (!affiche) return;
      affiche.style.background = baseBackground;
      regenerateBackground({ forceRandom });
    };

    const applyImageBackground = (dataURL) => {
      if (!affiche || !dataURL) return;
      affiche.style.background = `url(${dataURL}) center/cover no-repeat`;
      clearBackgroundLayer();
      enableTextDragMode(true);
      bgImageClearBtn?.removeAttribute('disabled');
    };

    const syncBackgroundControls = () => {
      const isGenerated = currentBgMode === 'generated';
      if (bgStyleSelect) bgStyleSelect.disabled = !isGenerated;
      if (solidBgColorInput) solidBgColorInput.disabled = currentBgMode !== 'solid';
      if (bgImageInput) bgImageInput.disabled = currentBgMode !== 'image';
      paletteModeInputs.forEach((radio) => {
        radio.disabled = !isGenerated;
      });
      const showCustom = isGenerated && currentPaletteMode === 'custom';
      if (customPaletteFields) {
        customPaletteFields.classList.toggle('is-visible', showCustom);
      }
      if (customColorAInput) customColorAInput.disabled = !showCustom;
      if (customColorBInput) customColorBInput.disabled = !showCustom;
      if (bgRandomBtn) bgRandomBtn.disabled = !isGenerated;
      if (bgImageClearBtn) {
        if (bgImageDataURL) {
          bgImageClearBtn.removeAttribute('disabled');
        } else {
          bgImageClearBtn.setAttribute('disabled', 'disabled');
        }
      }
    };

    const setBackgroundMode = (mode, options = {}) => {
      currentBgMode = mode;
      if (mode === 'solid') {
        applySolidBackground();
      } else if (mode === 'image') {
        if (bgImageDataURL) {
          applyImageBackground(bgImageDataURL);
        } else {
          enableTextDragMode(false);
          affiche.style.background = baseBackground;
          clearBackgroundLayer();
        }
      } else {
        applyGeneratedBackground(options);
      }
      syncBackgroundControls();
    };

    bgModeInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (input.checked) {
          setBackgroundMode(input.value);
        }
      });
    });

    solidBgColorInput?.addEventListener('input', () => {
      if (currentBgMode === 'solid') applySolidBackground();
    });

    const updateCustomPalette = () => {
      customPalette = [
        customColorAInput?.value || '#0A7F5A',
        customColorBInput?.value || '#A4D4AE',
      ];
      if (currentBgMode === 'generated' && currentPaletteMode === 'custom') {
        regenerateBackground();
      }
    };

    customColorAInput?.addEventListener('input', updateCustomPalette);
    customColorBInput?.addEventListener('input', updateCustomPalette);

    paletteModeInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (!input.checked) return;
        currentPaletteMode = input.value;
        syncBackgroundControls();
        if (currentBgMode === 'generated') regenerateBackground();
      });
    });

    bgImageInput?.addEventListener('change', async () => {
      const file = bgImageInput.files?.[0];
      if (!file) return;
      const dataURL = await readFileAsDataURL(file);
      bgImageDataURL = dataURL;
      const imageRadio = Array.from(bgModeInputs).find((input) => input.value === 'image');
      if (imageRadio) imageRadio.checked = true;
      setBackgroundMode('image');
    });

    bgImageClearBtn?.addEventListener('click', () => {
      bgImageDataURL = null;
      if (bgImageInput) bgImageInput.value = '';
      bgImageClearBtn.setAttribute('disabled', 'disabled');
      if (currentBgMode === 'image') {
        const solidRadio = Array.from(bgModeInputs).find((input) => input.value === 'solid');
        if (solidRadio) solidRadio.checked = true;
        setBackgroundMode('solid');
      }
    });

    updatePosterBtn?.addEventListener('click', () => {
      setBackgroundMode(currentBgMode);
      autoAdjustBands();
    });

    resetPosterBtn?.addEventListener('click', () => {
      resetPoster();
    });

    const suspendTransformsForCapture = () => {
      if (!affiche) return () => { };
      const posterRect = affiche.getBoundingClientRect();
      const adjustments = [];

      const recordStyle = (el, prop) => {
        let entry = adjustments.find((item) => item.el === el);
        if (!entry) {
          entry = { el, props: {} };
          adjustments.push(entry);
        }
        if (!(prop in entry.props)) {
          entry.props[prop] = el.style[prop] || '';
        }
      };

      const transformTargets = [
        headerBlock,
        footerBlock,
        afficheProduct,
        afficheBadge,
        afficheLogo,
      ];

      transformTargets.forEach((el) => {
        if (!el) return;
        const rect = el.getBoundingClientRect();
        ['transform', 'width', 'height', 'left', 'top', 'right', 'bottom'].forEach((prop) => recordStyle(el, prop));
        el.style.transform = 'none';
        el.style.width = `${rect.width}px`;
        el.style.height = `${rect.height}px`;
        el.style.left = `${rect.left - posterRect.left}px`;
        el.style.top = `${rect.top - posterRect.top}px`;
        el.style.right = 'auto';
        el.style.bottom = 'auto';
      });

      [afficheProduct, afficheLogo].forEach((el) => {
        if (!el) return;
        recordStyle(el, 'overflow');
        el.style.overflow = 'visible';
      });

      return () => {
        adjustments.forEach(({ el, props }) => {
          if (!el) return;
          Object.entries(props).forEach(([prop, value]) => {
            if (value === '') {
              el.style.removeProperty(prop);
            } else {
              el.style[prop] = value;
            }
          });
        });
      };
    };

    downloadPosterBtn?.addEventListener('click', async () => {
      if (!affiche) return;
      let restore = () => { };
      try {
        const html2canvas = await ensureHtml2Canvas();
        restore = suspendTransformsForCapture();
        const canvas = await html2canvas(affiche, {
          backgroundColor: null,
          scale: Math.min(2, window.devicePixelRatio || 1.5),
        });
        restore();
        const dataURL = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = 'affiche-demo.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } catch (error) {
        console.error('T√©l√©chargement impossible', error);
        alert("Impossible de g√©n√©rer l'image. R√©essayez ou utilisez le mode plein √©cran.");
      } finally {
        restore();
      }
    });


    const FONT_OPTIONS = ['Poppins', 'Playfair Display', 'Montserrat', 'Source Serif Pro', 'Raleway'];

    const rgbStringToHex = (color) => {
      const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      if (!match) return '#000000';
      return `#${match.slice(1, 4).map((val) => {
        const hex = parseInt(val, 10).toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
      }).join('')}`;
    };

    const ensureHtml2Canvas = async () => {
      if (!html2canvasPromise) {
        html2canvasPromise = import('https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/+esm');
      }
      const mod = await html2canvasPromise;
      return mod.default || mod;
    };

    let activeEditable = null;

    const syncToolbarWithElement = (element) => {
      if (!element) return;
      const styles = window.getComputedStyle(element);
      const family = FONT_OPTIONS.find((font) => styles.fontFamily.toLowerCase().includes(font.toLowerCase())) || FONT_OPTIONS[0];
      if (toolbarFontSelect) toolbarFontSelect.value = family;
      if (toolbarTextColor) toolbarTextColor.value = rgbStringToHex(styles.color);
    };

    const setActiveEditable = (element) => {
      if (activeEditable === element) {
        textDragConfig.enabled = Boolean(element);
        return;
      }
      if (activeEditable) activeEditable.classList.remove('is-editing');
      activeEditable = element;
      if (activeEditable) {
        activeEditable.classList.add('is-editing');
        if (editorStatus) editorStatus.textContent = activeEditable.dataset.label || 'Bloc s√©lectionn√©';
        syncToolbarWithElement(activeEditable);
      } else if (editorStatus) {
        editorStatus.textContent = 'S√©lectionnez un bloc de texte.';
      }
      textDragConfig.enabled = Boolean(activeEditable);
    };

    const clearActiveEditable = () => {
      if (activeEditable) {
        activeEditable.classList.remove('is-editing');
      }
      activeEditable = null;
      if (editorStatus) editorStatus.textContent = 'S√©lectionnez un bloc de texte.';
      textDragConfig.enabled = false;
    };

    const getElementAnchor = (element) => {
      if (!element) {
        return {
          x: window.innerWidth / 2,
          y: window.innerHeight / 2,
        };
      }
      const rect = element.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2,
        y: rect.bottom + 6,
      };
    };

    const getAnchorFromEvent = (event, element) => {
      if (event && typeof event.clientX === 'number') {
        return { x: event.clientX, y: event.clientY };
      }
      return getElementAnchor(element);
    };

    const positionContextToolbar = (anchor) => {
      if (!contextToolbar || !anchor) return;
      const { x, y } = anchor;
      const toolbarRect = contextToolbar.getBoundingClientRect();
      const padding = 12;
      let left = x + padding + window.scrollX;
      let top = y + padding + window.scrollY;
      const maxLeft = window.scrollX + window.innerWidth - toolbarRect.width - padding;
      const maxTop = window.scrollY + window.innerHeight - toolbarRect.height - padding;
      left = clamp(left, window.scrollX + padding, Math.max(window.scrollX + padding, maxLeft));
      top = clamp(top, window.scrollY + padding, Math.max(window.scrollY + padding, maxTop));
      contextToolbar.style.left = `${left}px`;
      contextToolbar.style.top = `${top}px`;
    };

    const toggleToolbarSections = (mode) => {
      if (!contextToolbar) return;
      if (bandToolbar) bandToolbar.style.display = mode === 'band' ? 'inline-flex' : 'none';
      if (textToolbar) textToolbar.style.display = mode === 'text' ? 'inline-flex' : 'none';
    };

    const showContextToolbar = (mode, anchor) => {
      if (!contextToolbar) return;
      activeToolbarMode = mode;
      toggleToolbarSections(mode);
      contextToolbar.classList.add('is-visible');
      requestAnimationFrame(() => positionContextToolbar(anchor));
    };

    const hideContextToolbar = () => {
      if (!contextToolbar) return;
      contextToolbar.classList.remove('is-visible');
      activeToolbarMode = null;
      activeBandTarget = null;
      if (bandDragConfig.pointerId && bandDragConfig.target?.releasePointerCapture) {
        bandDragConfig.target.releasePointerCapture(bandDragConfig.pointerId);
      }
      bandDragConfig.pointerId = null;
      bandDragConfig.target = null;
      if (textDragConfig.pointerId && activeEditable?.releasePointerCapture) {
        activeEditable.releasePointerCapture(textDragConfig.pointerId);
      }
      textDragConfig.enabled = false;
      textDragConfig.pointerId = null;
    };

    const parseBandColorVar = () => {
      const raw = (getComputedStyle(root).getPropertyValue('--band-color') || '#0a7f5a').trim();
      if (raw.startsWith('#')) {
        return { hex: raw, alpha: 1 };
      }
      const match = raw.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/i);
      if (!match) {
        return { hex: '#0a7f5a', alpha: 1 };
      }
      const [, rs, gs, bs, alpha = '1'] = match;
      const hex = rgbArrayToHex([Number(rs), Number(gs), Number(bs)]);
      return { hex, alpha: clampValue(parseFloat(alpha) || 1, 0, 1) };
    };

    const syncBandInputsFromCss = () => {
      if (!toolbarBandColor || !toolbarBandOpacity) return;
      const { hex, alpha } = parseBandColorVar();
      toolbarBandColor.value = hex;
      const percent = Math.round(alpha * 100);
      toolbarBandOpacity.value = percent;
      if (toolbarBandOpacityValue) toolbarBandOpacityValue.textContent = `${percent}%`;
    };

    const showBandToolbarFor = (target, event) => {
      if (!target) return;
      activeBandTarget = target;
      syncBandInputsFromCss();
      bandDragConfig.target = target;
      showContextToolbar('band', getAnchorFromEvent(event, target));
    };

    const showTextToolbarFor = (element, event) => {
      if (!element) return;
      setActiveEditable(element);
      showContextToolbar('text', getAnchorFromEvent(event, element));
    };

    const applyTextOffset = (element, x, y) => {
      if (!element) return;
      element.style.transform = `translate(${x}px, ${y}px)`;
      textOffsets.set(element, { x, y });
    };

    const ensureTextOffset = (element) => textOffsets.get(element) || { x: 0, y: 0 };

    const setupEditableDrag = (element) => {
      if (!element) return;
      element.addEventListener('pointerdown', (event) => {
        if (!textDragConfig.enabled || activeEditable !== element) return;
        textDragConfig.pointerId = event.pointerId;
        textDragConfig.startX = event.clientX;
        textDragConfig.startY = event.clientY;
        const { x, y } = ensureTextOffset(element);
        textDragConfig.baseX = x;
        textDragConfig.baseY = y;
        element.setPointerCapture(event.pointerId);
        event.preventDefault();

        const handleMove = (moveEvent) => {
          if (moveEvent.pointerId !== textDragConfig.pointerId) return;
          const dx = moveEvent.clientX - textDragConfig.startX;
          const dy = moveEvent.clientY - textDragConfig.startY;
          const nextX = clampValue(textDragConfig.baseX + dx, TEXT_DRAG_LIMITS.x[0], TEXT_DRAG_LIMITS.x[1]);
          const nextY = clampValue(textDragConfig.baseY + dy, TEXT_DRAG_LIMITS.y[0], TEXT_DRAG_LIMITS.y[1]);
          applyTextOffset(element, nextX, nextY);
        };

        const release = (endEvent) => {
          if (endEvent.pointerId !== textDragConfig.pointerId) return;
          element.releasePointerCapture(textDragConfig.pointerId);
          element.removeEventListener('pointermove', handleMove);
          element.removeEventListener('pointerup', release);
          element.removeEventListener('pointercancel', release);
          textDragConfig.pointerId = null;
        };

        element.addEventListener('pointermove', handleMove);
        element.addEventListener('pointerup', release);
        element.addEventListener('pointercancel', release);
      });
    };

    editableElements.forEach((el) => {
      el.setAttribute('contenteditable', 'true');
      el.setAttribute('spellcheck', 'false');
      el.addEventListener('focus', (event) => {
        showTextToolbarFor(el, event);
      });
      el.addEventListener('click', (event) => {
        event.stopPropagation();
        showTextToolbarFor(el, event);
      });
      el.addEventListener('input', () => {
        autoAdjustBands();
      });
      setupEditableDrag(el);
    });

    document.addEventListener('pointerdown', (event) => {
      if (contextToolbar?.contains(event.target)) return;
      if (event.target.closest('[data-editable]')) return;
      if (event.target.closest('.header-left') || event.target.closest('.footer-band')) return;
      clearActiveEditable();
      hideContextToolbar();
    });

    const setupHeaderMorphing = () => {
      if (!headerBlock || !affiche) return;
      headerBlock.addEventListener('pointerdown', (event) => {
        if (event.defaultPrevented) return;
        if (event.target.closest('[data-editable]')) return;
        const rect = headerBlock.getBoundingClientRect();
        const offsetX = event.clientX - rect.left;
        const offsetY = event.clientY - rect.top;
        const nearRight = rect.width - offsetX <= EDGE_TOLERANCE;
        const nearBottom = rect.height - offsetY <= EDGE_TOLERANCE;
        let mode = null;
        if (nearRight && nearBottom) {
          mode = 'corner';
        } else if (nearRight) {
          mode = 'width';
        } else if (nearBottom) {
          mode = 'depth';
        }
        if (!mode) return;
        event.preventDefault();
        const pointerId = event.pointerId;
        const startX = event.clientX;
        const startY = event.clientY;
        const base = {
          width: parseCssNumber('--header-width', 70),
          depth: parseCssNumber('--header-depth', 140),
          chamfer: parseCssNumber('--header-chamfer', 85),
          posterWidth: affiche.clientWidth || POSTER_BASE_WIDTH,
          rectWidth: rect.width || POSTER_BASE_WIDTH,
        };
        const handleMove = (moveEvent) => {
          if (moveEvent.pointerId !== pointerId) return;
          const dx = moveEvent.clientX - startX;
          const dy = moveEvent.clientY - startY;
          if (mode === 'width') {
            const deltaPercent = (dx / base.posterWidth) * 100;
            const next = clampValue(base.width + deltaPercent, HEADER_WIDTH_LIMITS[0], HEADER_WIDTH_LIMITS[1]);
            setBandVarManual('--header-width', next, '%');
          } else if (mode === 'depth') {
            const next = clampValue(base.depth + dy, HEADER_DEPTH_LIMITS[0], HEADER_DEPTH_LIMITS[1]);
            setBandVarManual('--header-depth', next, 'px');
          } else {
            const deltaPercent = (dx / base.rectWidth) * 100;
            const next = clampValue(base.chamfer + deltaPercent, HEADER_CHAMFER_LIMITS[0], HEADER_CHAMFER_LIMITS[1]);
            setBandVarManual('--header-chamfer', next, '%');
          }
        };
        const cleanup = (endEvent) => {
          if (endEvent.pointerId !== pointerId) return;
          headerBlock.releasePointerCapture(pointerId);
          headerBlock.removeEventListener('pointermove', handleMove);
          headerBlock.removeEventListener('pointerup', cleanup);
          headerBlock.removeEventListener('pointercancel', cleanup);
        };
        headerBlock.setPointerCapture(pointerId);
        headerBlock.addEventListener('pointermove', handleMove);
        headerBlock.addEventListener('pointerup', cleanup);
        headerBlock.addEventListener('pointercancel', cleanup);
      });
    };

    const setupFooterMorphing = () => {
      if (!footerBlock) return;
      footerBlock.addEventListener('pointerdown', (event) => {
        if (event.defaultPrevented) return;
        if (event.target.closest('[data-editable]')) return;
        const rect = footerBlock.getBoundingClientRect();
        const offsetX = event.clientX - rect.left;
        const offsetY = event.clientY - rect.top;
        const nearTop = offsetY <= EDGE_TOLERANCE;
        const nearBottom = rect.height - offsetY <= EDGE_TOLERANCE;
        let mode = null;
        if (nearTop && offsetX <= 120) {
          mode = 'notch-left';
        } else if (nearTop && rect.width - offsetX <= 120) {
          mode = 'notch-right';
        } else if (nearBottom) {
          mode = 'depth';
        }
        if (!mode) return;
        event.preventDefault();
        const pointerId = event.pointerId;
        const startY = event.clientY;
        const base = {
          depth: parseCssNumber('--footer-depth', 160),
          notchLeft: parseCssNumber('--footer-notch', 8),
          notchRight: parseCssNumber('--footer-notch-right', 0),
          rectHeight: rect.height || 200,
        };
        const handleMove = (moveEvent) => {
          if (moveEvent.pointerId !== pointerId) return;
          const dy = moveEvent.clientY - startY;
          if (mode === 'depth') {
            const next = clampValue(base.depth + dy, FOOTER_DEPTH_LIMITS[0], FOOTER_DEPTH_LIMITS[1]);
            setBandVarManual('--footer-depth', next, 'px');
          } else if (mode === 'notch-left') {
            const deltaPercent = (dy / base.rectHeight) * 100;
            const next = clampValue(base.notchLeft + deltaPercent, FOOTER_NOTCH_LIMITS[0], FOOTER_NOTCH_LIMITS[1]);
            setBandVarManual('--footer-notch', next, '%');
          } else if (mode === 'notch-right') {
            const deltaPercent = (dy / base.rectHeight) * 100;
            const next = clampValue(base.notchRight + deltaPercent, FOOTER_NOTCH_LIMITS[0], FOOTER_NOTCH_LIMITS[1]);
            setBandVarManual('--footer-notch-right', next, '%');
          }
        };
        const cleanup = (endEvent) => {
          if (endEvent.pointerId !== pointerId) return;
          footerBlock.releasePointerCapture(pointerId);
          footerBlock.removeEventListener('pointermove', handleMove);
          footerBlock.removeEventListener('pointerup', cleanup);
          footerBlock.removeEventListener('pointercancel', cleanup);
        };
        footerBlock.setPointerCapture(pointerId);
        footerBlock.addEventListener('pointermove', handleMove);
        footerBlock.addEventListener('pointerup', cleanup);
        footerBlock.addEventListener('pointercancel', cleanup);
      });
    };

    const setupGommetteMorphing = () => {
      if (!afficheBadge) return;
      afficheBadge.addEventListener('pointerdown', (event) => {
        if (event.defaultPrevented) return;
        if (event.target.closest('[data-editable]')) return;
        const rect = afficheBadge.getBoundingClientRect();
        const offsetX = event.clientX - rect.left;
        const offsetY = event.clientY - rect.top;
        const nearHorizontalEdge = offsetX <= EDGE_TOLERANCE || rect.width - offsetX <= EDGE_TOLERANCE;
        const nearVerticalEdge = offsetY <= EDGE_TOLERANCE || rect.height - offsetY <= EDGE_TOLERANCE;
        let mode = null;
        if (nearHorizontalEdge && nearVerticalEdge) {
          mode = 'both';
        } else if (nearHorizontalEdge) {
          mode = 'width';
        } else if (nearVerticalEdge) {
          mode = 'height';
        }
        if (!mode) return;
        event.preventDefault();
        const pointerId = event.pointerId;
        const startX = event.clientX;
        const startY = event.clientY;
        const base = {
          width: parseCssNumber('--gommette-width', 150),
          height: parseCssNumber('--gommette-height', 150),
        };
        const applyDimensions = (deltaX, deltaY) => {
          if (mode === 'width' || mode === 'both') {
            const nextWidth = clampValue(base.width + deltaX * 2, GOMMETTE_WIDTH_LIMITS[0], GOMMETTE_WIDTH_LIMITS[1]);
            root.style.setProperty('--gommette-width', `${nextWidth}px`);
          }
          if (mode === 'height' || mode === 'both') {
            const nextHeight = clampValue(base.height + deltaY * 2, GOMMETTE_HEIGHT_LIMITS[0], GOMMETTE_HEIGHT_LIMITS[1]);
            root.style.setProperty('--gommette-height', `${nextHeight}px`);
          }
        };
        const handleMove = (moveEvent) => {
          if (moveEvent.pointerId !== pointerId) return;
          const dx = moveEvent.clientX - startX;
          const dy = moveEvent.clientY - startY;
          applyDimensions(dx, dy);
        };
        const cleanup = (endEvent) => {
          if (endEvent.pointerId !== pointerId) return;
          afficheBadge.releasePointerCapture(pointerId);
          afficheBadge.removeEventListener('pointermove', handleMove);
          afficheBadge.removeEventListener('pointerup', cleanup);
          afficheBadge.removeEventListener('pointercancel', cleanup);
        };
        afficheBadge.setPointerCapture(pointerId);
        afficheBadge.addEventListener('pointermove', handleMove);
        afficheBadge.addEventListener('pointerup', cleanup);
        afficheBadge.addEventListener('pointercancel', cleanup);
      });
    };

    setupHeaderMorphing();
    setupFooterMorphing();
    setupGommetteMorphing();

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        clearActiveEditable();
        hideContextToolbar();
      }
    });
    toolbarFontSelect?.addEventListener('change', () => {
      if (!activeEditable) return;
      activeEditable.style.fontFamily = toolbarFontSelect.value;
    });

    toolbarTextColor?.addEventListener('input', () => {
      if (!activeEditable) return;
      activeEditable.style.color = toolbarTextColor.value;
    });

    sizeButtons.forEach((button) => {
      button.addEventListener('click', () => {
        if (!activeEditable) return;
        const delta = button.dataset.size === 'plus' ? 2 : -2;
        const styles = window.getComputedStyle(activeEditable);
        const current = parseInt(styles.fontSize, 10) || 24;
        const next = clampValue(current + delta, 12, 72);
        activeEditable.style.fontSize = `${next}px`;
        autoAdjustBands();
      });
    });

    toolbarBandColor?.addEventListener('input', updateBandColor);
    toolbarBandOpacity?.addEventListener('input', updateBandColor);

    const attachBandInteractions = (element) => {
      if (!element) return;
      element.addEventListener('click', (event) => {
        if (event.target.closest('[data-editable]')) return;
        event.stopPropagation();
        showBandToolbarFor(element, event);
      });

      element.addEventListener('pointerdown', (event) => {
        if (event.target.closest('[data-editable]')) return;
        const vars = bandShiftVars.get(element);
        if (!vars) return;
        bandDragConfig.target = element;
        bandDragConfig.pointerId = event.pointerId;
        bandDragConfig.startX = event.clientX;
        bandDragConfig.startY = event.clientY;
        bandDragConfig.baseX = getCssVarNumber(vars.xVar);
        bandDragConfig.baseY = getCssVarNumber(vars.yVar);
        element.setPointerCapture(event.pointerId);

        const handleMove = (moveEvent) => {
          if (moveEvent.pointerId !== bandDragConfig.pointerId) return;
          const dx = moveEvent.clientX - bandDragConfig.startX;
          const dy = moveEvent.clientY - bandDragConfig.startY;
          const nextX = clampValue(bandDragConfig.baseX + dx, BAND_DRAG_LIMITS.x[0], BAND_DRAG_LIMITS.x[1]);
          const nextY = clampValue(bandDragConfig.baseY + dy, BAND_DRAG_LIMITS.y[0], BAND_DRAG_LIMITS.y[1]);
          root.style.setProperty(vars.xVar, `${nextX}px`);
          root.style.setProperty(vars.yVar, `${nextY}px`);
        };

        const release = (endEvent) => {
          if (endEvent.pointerId !== bandDragConfig.pointerId) return;
          element.releasePointerCapture(bandDragConfig.pointerId);
          element.removeEventListener('pointermove', handleMove);
          element.removeEventListener('pointerup', release);
          element.removeEventListener('pointercancel', release);
          bandDragConfig.pointerId = null;
        };

        element.addEventListener('pointermove', handleMove);
        element.addEventListener('pointerup', release);
        element.addEventListener('pointercancel', release);
      });
    };

    attachBandInteractions(headerBlock);
    attachBandInteractions(footerBlock);
    const getToleranceValue = () => Number(toleranceRange?.value || 40);

    const setToleranceVisibility = (visible) => {
      if (!toleranceContainer) return;
      toleranceContainer.classList.toggle('is-visible', Boolean(visible));
    };
    setToleranceVisibility(false);

    function updateToleranceLabel() {
      if (toleranceValue) toleranceValue.textContent = getToleranceValue();
    }
    updateToleranceLabel();
    if (toleranceRange) {
      toleranceRange.addEventListener('input', async () => {
        updateToleranceLabel();
        await rerunColorIfNeeded();
      });
    }

    const resetDetourProgress = () => {
      if (!detourProgress) return;
      detourProgress.hidden = true;
      detourProgress.max = 100;
      detourProgress.value = 0;
      detourProgress.setAttribute('value', 0);
    };

    const handleModelDownloadProgress = (info) => {
      if (!detourProgress) return;
      const { percent = 0, total = 0, fromCache = false } = info ?? {};
      const label = getModelLabel();
      const completedDownload = total && percent >= 100 && !fromCache;

      if (fromCache) {
        resetDetourProgress();
        setDetourageStatus(`Mod√®le ${label} d√©j√† pr√™t (cache).`, 'idle');
        return;
      }

      if (completedDownload) {
        resetDetourProgress();
        setDetourageStatus(`T√©l√©chargement termin√©. Initialisation du mod√®le ${label}‚Ä¶`, 'loading');
        return;
      }

      detourProgress.hidden = false;
      if (total) {
        detourProgress.max = 100;
        detourProgress.value = percent;
        detourProgress.setAttribute('value', percent);
      } else {
        detourProgress.removeAttribute('value');
      }
      const message = total
        ? `T√©l√©chargement du mod√®le ${label}‚Ä¶ ${percent}%`
        : `T√©l√©chargement du mod√®le ${label}‚Ä¶`;
      setDetourageStatus(message, 'loading');
    };
    resetDetourProgress();

    const setDetourageStatus = (text, state = 'idle') => {
      if (!detourageStatusEl) return;
      detourageStatusEl.textContent = text;
      detourageStatusEl.classList.toggle('loading', state === 'loading');
      detourageStatusEl.classList.toggle('error', state === 'error');
      detourageStatusEl.classList.toggle('idle', state === 'idle');
    };
    setDetourageStatus(`Initialisation du mod√®le ${getModelLabel()}‚Ä¶`, 'loading');

    let u2netInitPromise;
    let providerLogged = false;

    const getSelectedDetourMode = () => {
      const checked = document.querySelector('input[name="detourageMode"]:checked');
      return (checked?.value || DETOUR_MODE.AUTO);
    };

    detourageModeInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (!input.checked) return;
        const wantsColor = input.value === DETOUR_MODE.COLOR;
        setToleranceVisibility(wantsColor);
      });
    });

    // --- G√©n√©rateur d'arri√®re-plan ---
    const ensureColorThief = () => {
      if (!colorThiefInstance && globalThis.ColorThief) {
        colorThiefInstance = new globalThis.ColorThief();
      }
      return colorThiefInstance;
    };

    // R√©cup√®re jusqu'√† 3 couleurs dominantes depuis le logo
    const extractBrandColors = (image) => {
      const thief = ensureColorThief();
      if (!thief || !image) {
        brandColors = [];
        return;
      }
      try {
        const palette = thief.getPalette(image, 3) || [];
        brandColors = palette.map((rgb) => rgbArrayToHex(rgb));
        if (currentBgMode === 'generated' && currentPaletteMode === 'logo') {
          regenerateBackground();
        }
      } catch (err) {
        console.warn('Impossible de r√©cup√©rer la palette du logo', err);
        brandColors = [];
      }
    };

    const getPaletteSource = () => {
      if (currentPaletteMode === 'custom') {
        return customPalette.length ? customPalette : DEFAULT_COLORS;
      }
      if (currentPaletteMode === 'logo' && brandColors.length) {
        return brandColors;
      }
      return DEFAULT_COLORS;
    };

    const shuffleArray = (arr = []) => {
      const copy = arr.slice();
      for (let i = copy.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    };

    // Assemble une palette douce avec de l√©g√®res variations al√©atoires
    const blendWithWhite = (hex, factor = 0.2) => {
      const { r, g, b } = hexToRgb(hex);
      const mix = (channel) => Math.round(channel + (255 - channel) * factor);
      return rgbArrayToHex([mix(r), mix(g), mix(b)]);
    };

    const buildPalette = (forceRandom = false) => {
      const base = getPaletteSource();
      const working = forceRandom ? shuffleArray(base) : base.slice();
      if (currentPaletteMode === 'custom') {
        return working.length ? working : DEFAULT_COLORS;
      }
      const softened = working.map((color, idx) => {
        const tinted = blendWithWhite(color, 0.15 + idx * 0.05);
        return adjustColor(tinted, (Math.random() - 0.5) * 0.08);
      });
      return softened.length ? softened : DEFAULT_COLORS;
    };

    // R√©initialise la couche d'arri√®re-plan avant une nouvelle g√©n√©ration
    const clearBgLayer = () => {
      if (!bgLayer) return;
      bgLayer.innerHTML = '';
      bgLayer.style.background = 'none';
      bgLayer.style.backgroundImage = 'none';
      bgLayer.style.backgroundColor = 'transparent';
    };

    // G√©n√®re un chemin sinuso√Ødal approximatif pour les vagues
    const wavePath = (width, height, baseY, amplitude) => {
      const segments = 5;
      const step = width / segments;
      let d = `M ${-step} ${baseY}`;
      for (let i = -1; i <= segments + 1; i += 1) {
        const x = i * step;
        const cpX1 = x + step / 3;
        const cpX2 = x + (2 * step) / 3;
        const cpY1 = baseY + Math.sin(i) * amplitude;
        const cpY2 = baseY + Math.cos(i) * amplitude * 0.8;
        const endX = x + step;
        const endY = baseY + Math.sin(i + 1) * amplitude * 0.6;
        d += ` C ${cpX1} ${cpY1} ${cpX2} ${cpY2} ${endX} ${endY}`;
      }
      d += ` L ${width} ${height} L 0 ${height} Z`;
      return d;
    };

    // Empile plusieurs vagues SVG discr√®tes
    const bgWaves = (colors) => {
      if (!bgLayer) return;
      clearBgLayer();
      const svgWidth = 600;
      const svgHeight = 800;
      let waves = '';
      for (let i = 0; i < 3; i += 1) {
        const color = colors[i % colors.length] || DEFAULT_COLORS[0];
        const baseY = 160 + i * 130 + randRange(-10, 10);
        const amplitude = 18 + i * 10;
        waves += `<path d="${wavePath(svgWidth, svgHeight, baseY, amplitude)}" fill="${rgba(color, 0.12 - i * 0.025)}" />`;
      }
      bgLayer.innerHTML = `<svg viewBox="0 0 ${svgWidth} ${svgHeight}" preserveAspectRatio="none">${waves}</svg>`;
    };

    const productSafeZone = {
      left: 140,
      right: 460,
      top: 210,
      bottom: 540,
    };

    const bubbleSizes = [70, 85, 95, 115, 135];

    const isInsideProductZone = (x, y, size) => {
      const cx = x + size / 2;
      const cy = y + size / 2;
      return (
        cx > productSafeZone.left &&
        cx < productSafeZone.right &&
        cy > productSafeZone.top &&
        cy < productSafeZone.bottom
      );
    };

    const hasOverlap = (placements, x, y, size) => {
      const cx = x + size / 2;
      const cy = y + size / 2;
      return placements.some(({ x: px, y: py, size: ps }) => {
        const pcx = px + ps / 2;
        const pcy = py + ps / 2;
        const minDist = (size + ps) / 2 + 25;
        const dist = Math.hypot(pcx - cx, pcy - cy);
        return dist < minDist;
      });
    };

    const createBubbleElement = (x, y, size, tone) => {
      const bubble = document.createElement('div');
      bubble.className = 'bubble dynamic';
      bubble.style.width = `${size}px`;
      bubble.style.height = `${size}px`;
      bubble.style.left = `${x}px`;
      bubble.style.top = `${y}px`;
      bubble.style.background = `rgba(255, 255, 255, ${tone})`;
      bubble.style.borderColor = `rgba(255, 255, 255, ${tone + 0.05})`;
      bubble.style.boxShadow = `0 3px 10px rgba(10, 127, 90, ${tone - 0.03})`;
      return bubble;
    };

    const bgBubbles = (colors) => {
      if (!bgLayer) return;
      clearBgLayer();
      const placements = [];
      const count = Math.floor(randRange(2, 6));
      let attempts = 0;
      while (placements.length < count && attempts < 80) {
        attempts += 1;
        const size = bubbleSizes[Math.floor(Math.random() * bubbleSizes.length)];
        const x = randRange(30, 600 - size - 30);
        const y = randRange(140, 800 - size - 40);
        if (isInsideProductZone(x, y, size)) continue;
        if (hasOverlap(placements, x, y, size)) continue;
        placements.push({ x, y, size });
      }
      placements.forEach(({ x, y, size }, idx) => {
        const tone = 0.12 + (idx % 3) * 0.035;
        const bubble = createBubbleElement(x, y, size, tone);
        bgLayer.appendChild(bubble);
      });
    };

    // Motif pointill√© bas√© sur des d√©grad√©s CSS
    const appendProductHalo = (intensity = 0.25) => {
      const halo = document.createElement('div');
      halo.style.position = 'absolute';
      halo.style.inset = '0';
      halo.style.background = `radial-gradient(circle at 50% 45%, rgba(255,255,255,${intensity}), transparent 55%)`;
      halo.style.pointerEvents = 'none';
      halo.style.zIndex = 0;
      bgLayer.appendChild(halo);
    };

    const bgDots = (colors) => {
      if (!bgLayer) return;
      clearBgLayer();
      const primary = colors[0] || DEFAULT_COLORS[0];
      const secondary = colors[1] || DEFAULT_COLORS[1];
      bgLayer.style.backgroundImage = `radial-gradient(${rgba(primary, 0.12)} 12%, transparent 20%), radial-gradient(${rgba(secondary, 0.08)} 10%, transparent 22%)`;
      bgLayer.style.backgroundSize = '20px 20px, 20px 20px';
      bgLayer.style.backgroundPosition = '0 0, 10px 10px';
      bgLayer.style.backgroundColor = rgba(adjustColor(primary, 0.3), 0.04);
      appendProductHalo(0.22);
    };

    // Motif croix r√©p√©t√© via pattern SVG
    const bgCross = (colors) => {
      if (!bgLayer) return;
      clearBgLayer();
      const stroke = colors[0] || DEFAULT_COLORS[0];
      const accent = colors[1] || DEFAULT_COLORS[1];
      const rotation = randRange(-12, 12).toFixed(2);
      const svg = `
        <svg viewBox="0 0 600 800" preserveAspectRatio="xMidYMid slice">
          <defs>
            <pattern id="crossPattern" width="32" height="32" patternUnits="userSpaceOnUse" patternTransform="rotate(${rotation})">
            <path d="M16 4 L16 28 M4 16 L28 16" stroke="${rgba(stroke, 0.12)}" stroke-width="1.5" stroke-linecap="round" />
            </pattern>
          </defs>
          <rect width="600" height="800" fill="url(#crossPattern)" fill-opacity="0.6" />
          <rect width="600" height="800" fill="${rgba(accent, 0.03)}" />
        </svg>`;
      bgLayer.innerHTML = svg;
      appendProductHalo(0.2);
    };

    const rendererMap = {
      bubbles: bgBubbles,
      waves: bgWaves,
      dots: bgDots,
      cross: bgCross,
    };

    const regenerateBackground = ({ forceRandom = false } = {}) => {
      if (!bgLayer || currentBgMode !== 'generated') return;
      const style = bgStyleSelect?.value || 'bubbles';
      const palette = buildPalette(forceRandom);
      const render = rendererMap[style] || bgBubbles;
      render(palette);
    };

    bgStyleSelect?.addEventListener('change', () => {
      if (currentBgMode === 'generated') regenerateBackground();
    });
    bgRandomBtn?.addEventListener('click', () => {
      if (currentBgMode !== 'generated') return;
      regenerateBackground({ forceRandom: true });
    });

    modelChoiceInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (!input.checked) return;
        if (!input.value || input.value === modelChoice) return;
        modelChoice = input.value;
        providerLogged = false;
        u2netInitPromise = null;
        resetDetourProgress();
        setDetourageStatus(`Pr√©paration du mod√®le ${getModelLabel()}‚Ä¶`, 'loading');
        ensureU2NetReady().catch(() => {
          // status already handled in ensureU2NetReady
        });
      });
    });

    // --- Module IA ---
    let initU2Net;
    let removeBgFromFile;
    try {
      ({ initU2Net, removeBgFromFile } = await import(MODULE_PATH));
    } catch (err) {
      console.error('Impossible de charger le module de d√©tourage :', err);
      setDetourageStatus('Module IA introuvable, utilisez "Couleur".', 'error');
    }

    const ensureU2NetReady = async () => {
      if (!initU2Net) {
        throw new Error('Module IA non disponible.');
      }
      if (!u2netInitPromise) {
        resetDetourProgress();
        setDetourageStatus(`Initialisation du mod√®le ${getModelLabel()}‚Ä¶`, 'loading');
        u2netInitPromise = initU2Net({
          modelUrl: getModelUrl(),
          providers: ['webgpu', 'webgl', 'wasm'],
          onProgress: handleModelDownloadProgress,
        })
          .then((session) => {
            console.log('[D√©tourage] Session U¬≤-Net initialis√©e.');
            resetDetourProgress();
            setDetourageStatus(`IA pr√™te (${getModelLabel()}) üü¢`, 'idle');
            return session;
          })
          .catch((err) => {
            console.error('initU2Net error', err);
            resetDetourProgress();
            setDetourageStatus('IA indisponible, essayez "Couleur".', 'error');
            throw err;
          });
      }
      return u2netInitPromise;
    };

    ensureU2NetReady().catch(() => {
      // Le flux Couleur reste disponible.
    });

    // --- Utilitaires g√©n√©raux ---
    const readFileAsDataURL = (file) => new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target.result);
      reader.onerror = () => reject(new Error('Lecture fichier impossible.'));
      reader.readAsDataURL(file);
    });

    const fileToImage = async (file) => {
      const dataURL = await readFileAsDataURL(file);
      const image = await new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = dataURL;
      });
      return { image, dataURL };
    };

    const loadImageFromDataURL = (dataURL) => new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = dataURL;
    });

    const injectImage = (container, dataURL) => {
      if (!container) return;
      container.innerHTML = '';
      const img = document.createElement('img');
      img.src = dataURL;
      container.appendChild(img);
      container.classList.add('has-image');
    };

    const isLikelyLogo = (file, img) => {
      if (!file || !img) return false;
      const name = (file.name || '').toLowerCase();
      if (/logo|mark/.test(name)) return true;
      return img.width < 256 || img.height < 256;
    };

    const applyUnsharpMask = (imageData) => {
      const { width, height, data } = imageData;
      const srcCopy = new Uint8ClampedArray(data);
      sampleCanvas.width = width;
      sampleCanvas.height = height;
      sampleCtx.putImageData(imageData, 0, 0);

      const blurCanvas = document.createElement('canvas');
      blurCanvas.width = width;
      blurCanvas.height = height;
      const blurCtx = blurCanvas.getContext('2d');
      if ('filter' in blurCtx) {
        blurCtx.filter = 'blur(1px)';
      }
      blurCtx.drawImage(sampleCanvas, 0, 0);
      const blurData = blurCtx.getImageData(0, 0, width, height).data;

      for (let i = 0; i < data.length; i += 4) {
        data[i] = clamp255(srcCopy[i] + 0.5 * (srcCopy[i] - blurData[i]));
        data[i + 1] = clamp255(srcCopy[i + 1] + 0.5 * (srcCopy[i + 1] - blurData[i + 1]));
        data[i + 2] = clamp255(srcCopy[i + 2] + 0.5 * (srcCopy[i + 2] - blurData[i + 2]));
      }
      return imageData;
    };

    const pickPixel = (imageData, x, y) => {
      const { width, data } = imageData;
      const idx = (y * width + x) * 4;
      return {
        r: data[idx],
        g: data[idx + 1],
        b: data[idx + 2],
      };
    };

    const applyColorKey = (imageData, keyColor, tolerance) => {
      const data = imageData.data;
      const threshold = Number.isFinite(tolerance) ? tolerance : 40;
      for (let i = 0; i < data.length; i += 4) {
        const dr = Math.abs(data[i] - keyColor.r);
        const dg = Math.abs(data[i + 1] - keyColor.g);
        const db = Math.abs(data[i + 2] - keyColor.b);
        const diff = dr + dg + db;
        data[i + 3] = diff <= threshold ? 0 : 255;
      }
    };

    const extractAlpha = (imageData) => {
      const len = imageData.width * imageData.height;
      const data = imageData.data;
      const alpha = new Float32Array(len);
      for (let i = 0; i < len; i += 1) {
        alpha[i] = data[i * 4 + 3] / 255;
      }
      return alpha;
    };

    const writeAlpha = (imageData, alpha) => {
      const len = imageData.width * imageData.height;
      const data = imageData.data;
      for (let i = 0; i < len; i += 1) {
        data[i * 4 + 3] = clamp255(Math.round(alpha[i] * 255));
      }
    };

    const dilateAlpha = (alpha, width, height) => {
      const out = new Float32Array(alpha.length);
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          let max = 0;
          for (let dy = -1; dy <= 1; dy += 1) {
            for (let dx = -1; dx <= 1; dx += 1) {
              const nx = clamp(x + dx, 0, width - 1);
              const ny = clamp(y + dy, 0, height - 1);
              max = Math.max(max, alpha[ny * width + nx]);
            }
          }
          out[y * width + x] = max;
        }
      }
      return out;
    };

    const erodeAlpha = (alpha, width, height) => {
      const out = new Float32Array(alpha.length);
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          let min = 1;
          for (let dy = -1; dy <= 1; dy += 1) {
            for (let dx = -1; dx <= 1; dx += 1) {
              const nx = clamp(x + dx, 0, width - 1);
              const ny = clamp(y + dy, 0, height - 1);
              min = Math.min(min, alpha[ny * width + nx]);
            }
          }
          out[y * width + x] = min;
        }
      }
      return out;
    };

    const blurAlpha = (alpha, width, height) => {
      const out = new Float32Array(alpha.length);
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          let acc = 0;
          let count = 0;
          for (let dy = -1; dy <= 1; dy += 1) {
            for (let dx = -1; dx <= 1; dx += 1) {
              const nx = clamp(x + dx, 0, width - 1);
              const ny = clamp(y + dy, 0, height - 1);
              acc += alpha[ny * width + nx];
              count += 1;
            }
          }
          out[y * width + x] = acc / count;
        }
      }
      return out;
    };

    const softenAlpha = (imageData) => {
      const width = imageData.width;
      const height = imageData.height;
      let alpha = extractAlpha(imageData);
      alpha = dilateAlpha(alpha, width, height);
      alpha = erodeAlpha(alpha, width, height);
      alpha = blurAlpha(alpha, width, height);
      writeAlpha(imageData, alpha);
    };

    const runColorKeyDetour = async (image, { tolerance, keyColor }) => {
      const canvas = document.createElement('canvas');
      canvas.width = image.width;
      canvas.height = image.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0);
      let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      imageData = applyUnsharpMask(imageData);
      ctx.putImageData(imageData, 0, 0);
      const working = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const sampledColor = keyColor || pickPixel(working, 0, 0);
      applyColorKey(working, sampledColor, tolerance);
      softenAlpha(working);
      ctx.putImageData(working, 0, 0);
      return { dataURL: canvas.toDataURL('image/png'), sampledColor };
    };

    const sampleColorFromOriginal = (image, ratioX, ratioY) => {
      if (!image) return null;
      sampleCanvas.width = image.width;
      sampleCanvas.height = image.height;
      sampleCtx.drawImage(image, 0, 0);
      const x = clamp(Math.round(clamp(ratioX, 0, 1) * (image.width - 1)), 0, image.width - 1);
      const y = clamp(Math.round(clamp(ratioY, 0, 1) * (image.height - 1)), 0, image.height - 1);
      const pixel = sampleCtx.getImageData(x, y, 1, 1).data;
      return { r: pixel[0], g: pixel[1], b: pixel[2] };
    };

    const isMaskFlat = async (alphaDataURL) => {
      if (!alphaDataURL) return false;
      try {
        const img = await loadImageFromDataURL(alphaDataURL);
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const { data } = ctx.getImageData(0, 0, canvas.width, canvas.height);

        let total = 0;
        let nearOpaque = 0;
        let nearTransparent = 0;
        for (let i = 0; i < data.length; i += 4) {
          const alpha = data[i];
          if (alpha >= 240) nearOpaque += 1;
          else if (alpha <= 15) nearTransparent += 1;
          total += 1;
        }
        if (!total) return true;
        const ratioOpaque = nearOpaque / total;
        const ratioTransparent = nearTransparent / total;
        return ratioOpaque > 0.995 || ratioTransparent > 0.995;
      } catch {
        return false;
      }
    };

    const smartDetour = async (file, image, requestedMode, { isLogo = false, manualKeyColor = null, tolerance = getToleranceValue() } = {}) => {
      let effectiveMode = requestedMode;
      if (effectiveMode === DETOUR_MODE.AUTO) {
        if (isLogo) {
          effectiveMode = DETOUR_MODE.COLOR;
        } else if (isLikelyLogo(file, image)) {
          effectiveMode = DETOUR_MODE.COLOR;
        } else {
          effectiveMode = DETOUR_MODE.IA;
        }
      }

      if (effectiveMode === DETOUR_MODE.IA) {
        await ensureU2NetReady();
        if (!removeBgFromFile) {
          throw new Error('removeBgFromFile indisponible.');
        }
        const result = await removeBgFromFile(file, { feather: 1.5, threshold: 0.7 });
        if (!providerLogged && result?.provider) {
          console.log(`[D√©tourage] Provider IA utilis√© : ${result.provider}`);
          providerLogged = true;
        }
        if (await isMaskFlat(result?.alphaMask)) {
          throw new Error('flat_mask');
        }
        return { dataURL: result.rgbaDataURL, modeUsed: DETOUR_MODE.IA, provider: result?.provider || 'inconnu' };
      }

      const { dataURL, sampledColor } = await runColorKeyDetour(image, {
        tolerance,
        keyColor: manualKeyColor,
      });
      return {
        dataURL,
        modeUsed: DETOUR_MODE.COLOR,
        sampledColor,
      };
    };

    async function rerunColorIfNeeded() {
      if (state.lastLogoMode === DETOUR_MODE.COLOR && state.lastLogoImage) {
        await rerunLogoColor();
      } else if (state.lastProductMode === DETOUR_MODE.COLOR && state.lastProductImage) {
        await rerunProductColor();
      }
    }

    async function rerunLogoColor() {
      if (!state.lastLogoImage || !state.lastLogoFile) return;
      setDetourageStatus('Ajustement du logo‚Ä¶', 'loading');
      try {
        const result = await smartDetour(state.lastLogoFile, state.lastLogoImage, DETOUR_MODE.COLOR, {
          isLogo: true,
          manualKeyColor: state.logoManualColor,
          tolerance: getToleranceValue(),
        });
        injectImage(afficheLogo, result.dataURL);
        state.lastLogoMode = result.modeUsed;
        setDetourageStatus('Logo √† jour ‚úÖ');
      } catch (err) {
        console.error('Erreur d√©tourage logo', err);
        setDetourageStatus('Logo non mis √† jour.', 'error');
      }
    }

    async function rerunProductColor() {
      if (!state.lastProductImage || !state.lastProductFile) return;
      setDetourageStatus('Ajustement du produit‚Ä¶', 'loading');
      try {
        const result = await smartDetour(state.lastProductFile, state.lastProductImage, DETOUR_MODE.COLOR, {
          tolerance: getToleranceValue(),
        });
        injectImage(afficheProduct, result.dataURL);
        state.lastProductMode = result.modeUsed;
        setDetourageStatus('Produit mis √† jour ‚úÖ');
      } catch (err) {
        console.error('Erreur d√©tourage produit', err);
        setDetourageStatus('Produit non mis √† jour.', 'error');
      }
    }

    // --- Gestionnaires upload ---
    const handleLogoChange = async () => {
      const file = logoInput?.files?.[0];
      if (!file) return;
      setDetourageStatus('D√©tection du logo‚Ä¶', 'loading');
      let lastDataURL;
      try {
        const { image, dataURL } = await fileToImage(file);
        state.lastLogoImage = image;
        state.lastLogoFile = file;
        state.lastLogoDataURL = dataURL;
        lastDataURL = dataURL;
        state.logoManualColor = null;
        extractBrandColors(image);

        const result = await smartDetour(file, image, getSelectedDetourMode(), { isLogo: true });
        injectImage(afficheLogo, result.dataURL);
        state.lastLogoMode = result.modeUsed;
        setToleranceVisibility(result.modeUsed === DETOUR_MODE.COLOR);
        setDetourageStatus(result.modeUsed === DETOUR_MODE.IA ? 'Logo d√©tour√© par IA ‚úÖ' : 'Logo d√©tour√© ‚úÖ');
      } catch (err) {
        console.error('Logo detour error', err);
        const isFlatMask = err?.message === 'flat_mask';
        const message = isFlatMask ? 'IA confuse sur ce logo, testez "Couleur".' : '√âchec d√©tourage logo.';
        setDetourageStatus(`${message} (affich√© avec fond)`, 'error');
        if (lastDataURL) {
          injectImage(afficheLogo, lastDataURL);
          state.lastLogoMode = null;
          setToleranceVisibility(getSelectedDetourMode() === DETOUR_MODE.COLOR);
        }
      } finally {
        regenerateBackground({ forceRandom: true });
      }
    };

    const handleProductChange = async () => {
      const file = productInput?.files?.[0];
      if (!file) return;
      setDetourageStatus('D√©tourage du produit‚Ä¶', 'loading');
      let lastDataURL;
      try {
        const { image, dataURL } = await fileToImage(file);
        state.lastProductImage = image;
        state.lastProductFile = file;
        lastDataURL = dataURL;

        const result = await smartDetour(file, image, getSelectedDetourMode());
        injectImage(afficheProduct, result.dataURL);
        state.lastProductMode = result.modeUsed;
        lastDataURL = result.dataURL;
        setToleranceVisibility(result.modeUsed === DETOUR_MODE.COLOR);
        if (result.modeUsed === DETOUR_MODE.IA) {
          setDetourageStatus(`Produit d√©tour√© par IA (${result.provider || 'IA'}) ‚úÖ`);
        } else {
          setDetourageStatus('Produit d√©tour√© (Couleur) ‚úÖ');
        }
      } catch (err) {
        console.error('Product detour error', err);
        const isFlatMask = err?.message === 'flat_mask';
        const msg = isFlatMask
          ? 'IA h√©sitante : essayez "Forcer Couleur".'
          : '√âchec IA, essayez "Forcer Couleur".';
        setDetourageStatus(`${msg} (affich√© avec fond)`, 'error');
        if (lastDataURL) {
          injectImage(afficheProduct, lastDataURL);
          state.lastProductMode = null;
          setToleranceVisibility(getSelectedDetourMode() === DETOUR_MODE.COLOR);
        }
      }
    };

    logoInput?.addEventListener('change', handleLogoChange);
    productInput?.addEventListener('change', handleProductChange);

    // Eyedropper sur le logo
    afficheLogo?.addEventListener('click', async (event) => {
      if (state.lastLogoMode !== DETOUR_MODE.COLOR || !state.lastLogoImage) return;
      const img = afficheLogo.querySelector('img');
      if (!img) return;
      const rect = img.getBoundingClientRect();
      const ratioX = (event.clientX - rect.left) / rect.width;
      const ratioY = (event.clientY - rect.top) / rect.height;
      const sampled = sampleColorFromOriginal(state.lastLogoImage, ratioX, ratioY);
      if (!sampled) return;
      state.logoManualColor = sampled;
      await rerunLogoColor();
    });

    // --- Interactions directes (drag + zoom) ---
    const setupTransformHandle = (element, {
      dxVar,
      dyVar,
      scaleVar,
      minScale = 0.5,
      maxScale = 2.5,
      clampX = [-300, 300],
      clampY = [-300, 300],
    }) => {
      if (!element) return;
      const state = {
        x: parseFloat(getComputedStyle(root).getPropertyValue(dxVar)) || 0,
        y: parseFloat(getComputedStyle(root).getPropertyValue(dyVar)) || 0,
        scale: parseFloat(getComputedStyle(root).getPropertyValue(scaleVar)) || 1,
      };

      const apply = () => {
        state.x = clampValue(state.x, clampX[0], clampX[1]);
        state.y = clampValue(state.y, clampY[0], clampY[1]);
        root.style.setProperty(dxVar, `${state.x}px`);
        root.style.setProperty(dyVar, `${state.y}px`);
        root.style.setProperty(scaleVar, String(state.scale));
      };
      apply();

      const activePointers = new Map();
      let primaryPointerId = null;
      let panStart = { x: state.x, y: state.y };
      let pinchStartDist = 0;
      let pinchStartScale = state.scale;

      const updateFromPointers = () => {
        if (activePointers.size === 0) {
          element.classList.remove('dragging');
          return;
        }
        if (activePointers.size === 1 && primaryPointerId) {
          const pointer = activePointers.get(primaryPointerId);
          if (!pointer) return;
          const dx = pointer.currentX - pointer.startX;
          const dy = pointer.currentY - pointer.startY;
          state.x = panStart.x + dx;
          state.y = panStart.y + dy;
          apply();
        } else if (activePointers.size >= 2) {
          const pointers = Array.from(activePointers.values());
          if (pointers.length < 2 || pinchStartDist === 0) return;
          const dist = Math.hypot(
            pointers[0].currentX - pointers[1].currentX,
            pointers[0].currentY - pointers[1].currentY,
          );
          if (!dist) return;
          state.scale = clampValue(pinchStartScale * (dist / pinchStartDist), minScale, maxScale);
          apply();
        }
      };

      const handlePointerDown = (event) => {
        if (event.defaultPrevented) return;
        if (event.target && event.target.closest('[data-editable]')) {
          return;
        }
        event.preventDefault();
        element.setPointerCapture(event.pointerId);
        activePointers.set(event.pointerId, {
          startX: event.clientX,
          startY: event.clientY,
          currentX: event.clientX,
          currentY: event.clientY,
        });
        if (primaryPointerId === null) {
          primaryPointerId = event.pointerId;
          panStart = { x: state.x, y: state.y };
        } else if (activePointers.size === 2) {
          const pointers = Array.from(activePointers.values());
          pinchStartDist = Math.hypot(
            pointers[0].currentX - pointers[1].currentX,
            pointers[0].currentY - pointers[1].currentY,
          );
          pinchStartScale = state.scale;
        }
        element.classList.add('dragging');
      };

      const handlePointerMove = (event) => {
        if (!activePointers.has(event.pointerId)) return;
        const data = activePointers.get(event.pointerId);
        data.currentX = event.clientX;
        data.currentY = event.clientY;
        updateFromPointers();
      };

      const cleanupPointer = (event) => {
        if (element.hasPointerCapture?.(event.pointerId)) {
          element.releasePointerCapture(event.pointerId);
        }
        if (activePointers.has(event.pointerId)) {
          activePointers.delete(event.pointerId);
        }
        if (primaryPointerId === event.pointerId) {
          primaryPointerId = activePointers.size ? Array.from(activePointers.keys())[0] : null;
          if (primaryPointerId) {
            const pointer = activePointers.get(primaryPointerId);
            panStart = {
              x: state.x - (pointer.currentX - pointer.startX),
              y: state.y - (pointer.currentY - pointer.startY),
            };
          }
        }
        if (activePointers.size < 2) {
          pinchStartDist = 0;
        }
        updateFromPointers();
      };

      const handleWheel = (event) => {
        event.preventDefault();
        const delta = -event.deltaY;
        const factor = delta > 0 ? 1.05 : 0.95;
        state.scale = clampValue(state.scale * factor, minScale, maxScale);
        apply();
      };

      element.addEventListener('pointerdown', handlePointerDown);
      element.addEventListener('pointermove', handlePointerMove);
      element.addEventListener('pointerup', cleanupPointer);
      element.addEventListener('pointercancel', cleanupPointer);
      element.addEventListener('wheel', handleWheel, { passive: false });
    };

    setupTransformHandle(document.getElementById('afficheProduct'), {
      dxVar: '--product-shift-x',
      dyVar: '--product-shift-y',
      scaleVar: '--product-scale',
      minScale: 0.4,
      maxScale: 2.5,
    });

    setupTransformHandle(document.getElementById('afficheBadge'), {
      dxVar: '--gommette-shift-x',
      dyVar: '--gommette-shift-y',
      scaleVar: '--gommette-scale',
      minScale: 0.5,
      maxScale: 1.8,
    });

    setupTransformHandle(document.getElementById('afficheLogo'), {
      dxVar: '--logo-shift-x',
      dyVar: '--logo-shift-y',
      scaleVar: '--logo-scale',
      minScale: 0.3,
      maxScale: 2.3,
      clampX: [-420, 420],
      clampY: [-320, 320],
    });

    const setupTextDragHandle = (handle, xVar, yVar) => {
      if (!handle) return;
      let pointerId = null;
      const pointerState = {};

      const apply = (x, y) => {
        root.style.setProperty(xVar, `${x}px`);
        root.style.setProperty(yVar, `${y}px`);
      };

      const onPointerMove = (event) => {
        if (event.pointerId !== pointerId || currentBgMode !== 'image') return;
        const dx = event.clientX - pointerState.startX;
        const dy = event.clientY - pointerState.startY;
        const nextX = clampValue(pointerState.baseX + dx, -240, 240);
        const nextY = clampValue(pointerState.baseY + dy, -220, 240);
        apply(nextX, nextY);
      };

      const releasePointer = (event) => {
        if (event.pointerId !== pointerId) return;
        handle.releasePointerCapture(pointerId);
        handle.removeEventListener('pointermove', onPointerMove);
        handle.removeEventListener('pointerup', releasePointer);
        handle.removeEventListener('pointercancel', releasePointer);
        pointerId = null;
      };

      handle.addEventListener('pointerdown', (event) => {
        if (currentBgMode !== 'image') return;
        event.preventDefault();
        pointerId = event.pointerId;
        pointerState.startX = event.clientX;
        pointerState.startY = event.clientY;
        pointerState.baseX = getCssVarNumber(xVar);
        pointerState.baseY = getCssVarNumber(yVar);
        handle.setPointerCapture(pointerId);
        handle.addEventListener('pointermove', onPointerMove);
        handle.addEventListener('pointerup', releasePointer);
        handle.addEventListener('pointercancel', releasePointer);
      });
    };

    setupTextDragHandle(headerDragHandle, '--header-shift-x', '--header-shift-y');
    setupTextDragHandle(footerDragHandle, '--footer-shift-x', '--footer-shift-y');

    // --- Contr√¥les bandeaux ---
    const initialBgMode = Array.from(bgModeInputs).find((input) => input.checked)?.value || 'solid';
    setBackgroundMode(initialBgMode);
    syncBandInputsFromCss();
    updateBandColor();
    autoAdjustBands();
  </script>

  <footer class="site-footer">
    ¬© 2025 Edimah SYNESIUS SONGO ‚Äî Tous droits r√©serv√©s. Produit prot√©g√© par le droit d‚Äôauteur. Reproduction,
    modification ou diffusion interdite sans autorisation √©crite de l‚Äôautrice.
  </footer>
</body>

</html>