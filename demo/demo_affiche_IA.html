<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8" />
  <title>Assistant Affiche IA - D√©mo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Police -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/colorthief/dist/color-thief.umd.js"></script>

  <style>
    :root {
      --green: #0A7F5A;
      --green-light: #e9f5ef;
      --feather: 16px;
      --top-slope: 10deg;
      --bottom-slope: -10deg;
      --radius: 18px;
      --header-width: 70%;
      --header-depth: 120px;
      --header-angle: 88%;
      --logo-scale: 1;
      --footer-depth: 140px;
      --footer-notch: 8%;
      --header-shift-x: 0px;
      --header-shift-y: 0px;
      --footer-shift-x: 0px;
      --footer-shift-y: 0px;
      --product-shift-x: 0px;
      --product-shift-y: 0px;
      --product-scale: 1;
      --gommette-shift-x: 0px;
      --gommette-shift-y: 0px;
      --gommette-scale: 1;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: "Poppins", Arial, sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 20px;
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }

    /* PANNEAUX */
    .controls {
      width: 360px;
      background: #fff;
      padding: 15px 15px 20px;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, .05);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .controls-right {
      width: 320px;
      position: sticky;
      top: 20px;
    }

    .controls h2 {
      margin-top: 0;
      color: var(--green);
      font-size: 1.05rem;
    }

    .controls label {
      font-weight: 600;
      font-size: .78rem;
    }

    .range-control {
      display: flex;
      flex-direction: column;
      gap: 3px;
      margin-bottom: 8px;
    }

    .range-control label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: .7rem;
      font-weight: 600;
    }

    .range-control span {
      font-weight: 500;
      font-size: .68rem;
      color: #395247;
    }

    .range-control input[type="range"] {
      width: 100%;
    }

    .controls input[type="text"],
    .controls input[type="file"] {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #e1e1e1;
      border-radius: 6px;
      font-size: .8rem;
      background: #fff;
    }

    .controls button {
      width: 100%;
      background: var(--green);
      color: #fff;
      border: none;
      padding: 9px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: .85rem;
    }

    .editor-hint {
      font-size: .75rem;
      color: #4a5b55;
      margin: 2px 0 10px;
      line-height: 1.3;
    }

    .editor-status {
      padding: 8px 10px;
      border: 1px dashed rgba(10, 127, 90, .35);
      border-radius: 8px;
      font-size: .78rem;
      color: #0b4f3a;
      background: #f4faf7;
      margin-bottom: 12px;
      min-height: 36px;
      display: flex;
      align-items: center;
    }

    .style-panel {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .style-panel label {
      font-size: .76rem;
      font-weight: 600;
      color: #34423d;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
    }

    .style-panel select,
    .style-panel input[type="range"],
    .style-panel input[type="color"] {
      width: 100%;
      border: 1px solid #d7e2dc;
      border-radius: 6px;
      padding: 6px 8px;
      font-size: .78rem;
      background: #fff;
    }

    .style-panel input[type="color"] {
      height: 40px;
      padding: 2px;
      cursor: pointer;
    }

    #fontSizeValue {
      font-weight: 500;
      color: #0a7f5a;
      font-size: .75rem;
    }

    .bg-mode {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
    }

    .bg-mode-option {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: .8rem;
      font-weight: 600;
      color: #1d3a31;
    }

    .bg-mode input[type="color"],
    .bg-mode input[type="file"],
    .bg-mode select {
      width: 100%;
      border: 1px solid #d7e2dc;
      border-radius: 6px;
      padding: 6px 8px;
      font-size: .78rem;
      background: #fff;
    }

    .palette-choice {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 8px;
      font-size: .78rem;
      font-weight: 600;
      color: #2f463d;
    }

    .custom-palette-fields {
      display: none;
      gap: 8px;
      margin-top: 6px;
    }

    .custom-palette-fields.is-visible {
      display: flex;
    }

    .custom-palette-fields input[type="color"] {
      flex: 1;
      height: 42px;
    }

    [data-editable] {
      cursor: text;
      outline: 2px solid transparent;
      transition: outline-color .15s ease, background .15s ease;
    }

    [data-editable].is-editing {
      outline-color: rgba(255, 255, 255, .6);
      background: rgba(255, 255, 255, .04);
    }

    .drag-handle-star {
      position: absolute;
      width: 34px;
      height: 34px;
      border-radius: 50%;
      background: rgba(0, 0, 0, .35);
      border: 1px solid rgba(255, 255, 255, .35);
      color: #fff;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      z-index: 30;
      cursor: move;
      pointer-events: auto;
      box-shadow: 0 6px 14px rgba(0, 0, 0, .25);
    }

    .drag-handle-star:focus-visible {
      outline: 2px solid #fff;
      outline-offset: 2px;
    }

    .drag-handle-star.header-star {
      top: 18px;
      right: 18px;
    }

    .drag-handle-star.footer-star {
      bottom: calc(var(--footer-depth) + 10px);
      right: 24px;
    }

    .affiche.has-model-bg .drag-handle-star {
      display: flex;
    }

    .affiche.has-model-bg .header-left,
    .affiche.has-model-bg .footer-band {
      background: rgba(5, 12, 10, .58);
      color: #fff;
      backdrop-filter: blur(5px);
    }

    .affiche.has-model-bg .header-left::after,
    .affiche.has-model-bg .footer-band::before {
      display: none;
    }

    .controls select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #e1e1e1;
      border-radius: 6px;
      font-size: .8rem;
      background: #fff;
    }

    .detourage-panel {
      border: 1px dashed rgba(10, 127, 90, .35);
      border-radius: 10px;
      padding: 10px;
      margin-top: 4px;
      background: #f6faf8;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: .75rem;
    }

    .detourage-panel legend {
      font-weight: 600;
      font-size: .78rem;
      color: var(--green);
    }

    .detourage-modes {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .detourage-modes label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: .74rem;
      font-weight: 500;
      color: #395247;
    }

    .detourage-modes input[type="radio"] {
      accent-color: var(--green);
    }

    .tolerance-control {
      display: none;
      flex-direction: column;
      gap: 4px;
    }

    .tolerance-control.is-visible {
      display: flex;
    }

    .tolerance-control label {
      display: flex;
      justify-content: space-between;
      font-size: .7rem;
      font-weight: 600;
      color: #395247;
    }

    .tolerance-control input[type="range"] {
      width: 100%;
    }

    .detourage-note {
      font-size: .68rem;
      color: #7a8a81;
      margin: 0;
    }

    .model-choice {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 6px;
      border-radius: 8px;
      background: rgba(255, 255, 255, .65);
      border: 1px dashed rgba(10, 127, 90, .18);
      margin-top: 4px;
    }

    .model-choice span {
      display: inline-flex;
      align-items: baseline;
      gap: 6px;
    }

    .model-choice label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: .74rem;
      font-weight: 500;
      color: #395247;
    }

    .model-choice small {
      font-size: .68rem;
      color: #7a8a81;
    }

    .detourage-status {
      margin-top: 6px;
      font-size: .7rem;
      color: #395247;
      display: flex;
      align-items: center;
      gap: 6px;
      min-height: 18px;
    }

    .detourage-status::before {
      content: "üü¢";
      font-size: .7rem;
    }

    .detourage-status.loading::before {
      content: "";
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid rgba(9, 90, 65, .2);
      border-top-color: rgba(9, 90, 65, .8);
      animation: spin 0.8s linear infinite;
    }

    .detourage-status.error::before {
      content: "‚ö†Ô∏è";
      animation: none;
    }

    .bg-style-controls {
      margin-top: 6px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .bg-checkbox {
      font-size: .75rem;
      font-weight: 500;
      color: #395247;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .bg-checkbox input[type="checkbox"] {
      width: auto;
      accent-color: var(--green);
    }

    .bg-random-btn {
      width: auto !important;
      padding: 6px 14px;
      font-size: .75rem !important;
      flex-shrink: 0;
    }

    #bgLayer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      overflow: hidden;
      border-radius: inherit;
      mix-blend-mode: normal;
    }

    #bgLayer svg {
      width: 100%;
      height: 100%;
    }

    .progress {
      width: 100%;
      height: 0.6rem;
      border-radius: 999px;
      overflow: hidden;
      background: #e2e8f0;
      border: none;
      display: block;
    }

    .progress::-webkit-progress-bar {
      background: transparent;
    }

    .progress::-webkit-progress-value {
      background: linear-gradient(90deg, #60a5fa, #2563eb);
      border-radius: 999px;
    }

    .progress::-moz-progress-bar {
      background: linear-gradient(90deg, #60a5fa, #2563eb);
      border-radius: 999px;
    }

    .controls button.secondary {
      background: #fff;
      color: var(--green);
      border: 1px solid rgba(10, 127, 90, .2);
    }

    .control-block {
      background: #f8f8f8;
      border: 1px solid rgba(0, 0, 0, .03);
      border-radius: 8px;
      padding: 6px;
    }

    .control-title {
      font-size: .7rem;
      font-weight: 600;
      margin-bottom: 4px;
      color: #494f4d;
    }

    /* CROIX + ZOOM (robuste via grid-areas) */
    /* PREVIEW */
    .preview-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-width: 620px;
    }

    .affiche {
      width: 600px;
      height: 800px;
      background: radial-gradient(circle at top, #ffffff 0%, var(--green-light) 40%, #d7ece1 100%);
      border-radius: var(--radius);
      position: relative;
      overflow: hidden;
      box-shadow: 0 6px 15px rgba(0, 0, 0, .12);
    }

    /* Bandeau haut */
    /* Bandeau haut arrondi et plus clair */
    .header-left {
      position: absolute;
      top: 0;
      left: 0;
      background: #0c8b64;
      /* plus clair que #0a7f5a */
      color: white;
      width: clamp(45%, var(--header-width), 95%);
      min-height: clamp(90px, var(--header-depth), 280px);
      padding: clamp(12px, calc(var(--header-depth) * 0.15), 32px) 18px clamp(18px, calc(var(--header-depth) * 0.35), 48px) 22px;
      border-bottom-right-radius: 38px 42px;
      /* courbure douce */
      clip-path: path("M0,0 H100% L85%,100 Q75%,110 0,100 Z");
      /* arrondi organique */
      z-index: 12;
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.08);
      transition: width .2s ease, min-height .2s ease, padding .2s ease, transform .2s ease;
      transform: translate(var(--header-shift-x, 0px), var(--header-shift-y, 0px));
    }

    .header-left::after {
      content: "";
      position: absolute;
      inset: -18px;
      background:
        linear-gradient(110deg,
          rgba(10, 127, 90, .65) 6%,
          rgba(10, 127, 90, .4) 15%,
          rgba(10, 127, 90, 0) 20%);
      clip-path: polygon(0 0, 100% 0, var(--header-angle) 100%, 0 100%);
      filter: blur(18px);
      opacity: .75;
      z-index: -1;
      pointer-events: none;
    }

    .header-left .promo-title {
      font-size: 1.05rem;
      font-weight: 700;
      margin: 0;
    }

    .header-left .promo-date {
      font-size: .7rem;
      margin: 4px 0 0;
      opacity: .92;
    }

    /* LOGO */
    .logo {
      position: absolute;
      top: 18px;
      right: 18px;
      width: calc(110px * var(--logo-scale));
      height: calc(60px * var(--logo-scale));
      background: transparent;
      border-radius: 14px;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      border: none;
      z-index: 4;
    }

    .logo img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .logo .placeholder {
      font-size: .65rem;
      color: rgba(0, 0, 0, .4);
      text-align: center;
      background: rgba(255, 255, 255, .25);
      padding: 4px 6px;
      border-radius: 8px;
    }

    /* GOMMETTE */
    .gommette {
      position: absolute;
      top: 120px;
      right: 35px;
      width: 150px;
      height: 150px;
      background: radial-gradient(circle, #ff9a7a 0%, #ff7b5a 45%, #ff5c32 100%);
      border-radius: 50%;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-weight: 700;
      font-size: 1.3rem;
      letter-spacing: .01em;
      box-shadow: 0 8px 18px rgba(255, 123, 90, .42);
      z-index: 13;
      isolation: isolate;
      transform-origin: center center;
      transform: translate(var(--gommette-shift-x, 0px), var(--gommette-shift-y, 0px)) scale(var(--gommette-scale, 1));
      touch-action: none;
      cursor: grab;
      user-select: none;
    }

    .gommette::after {
      content: "";
      position: absolute;
      inset: -18px;
      background: radial-gradient(circle, rgba(255, 123, 90, .35) 0%, rgba(255, 123, 90, 0) 70%);
      filter: blur(12px);
      z-index: -1;
      pointer-events: none;
    }

    /* PRODUIT */
    .product-image {
      position: absolute;
      top: 235px;
      left: 50%;
      transform: translateX(-50%) translate(var(--product-shift-x, 0px), var(--product-shift-y, 0px)) scale(var(--product-scale, 1));
      width: 360px;
      height: 280px;
      background: transparent;
      border: none;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      z-index: 11;
      transform-origin: center center;
      isolation: isolate;
      transition: .25s ease;
      touch-action: none;
      cursor: grab;
      user-select: none;
    }

    .product-image::after {
      content: "";
      position: absolute;
      inset: -28px;
      background: radial-gradient(circle,
          rgba(255, 255, 255, .85) 0%,
          rgba(255, 255, 255, .28) 55%,
          rgba(255, 255, 255, 0) 80%);
      filter: blur(18px);
      opacity: 0;
      transform: scale(.9);
      transition: .25s ease;
      pointer-events: none;
      z-index: -1;
    }

    .product-image.has-image::after {
      opacity: .8;
      transform: scale(1);
    }

    .product-image img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      background: transparent;
      position: relative;
      z-index: 1;
      transition: .25s ease;
      pointer-events: none;
    }

    .product-image.has-image img {
      filter: drop-shadow(0 12px 24px rgba(10, 127, 90, .25));
    }

    .product-image.dragging,
    .gommette.dragging {
      cursor: grabbing;
    }

    .product-placeholder {
      color: rgba(10, 127, 90, .5);
      text-align: center;
      font-size: .85rem;
      opacity: .6;
      background: rgba(255, 255, 255, .25);
      padding: 8px 10px;
      border-radius: 999px;
      pointer-events: none;
    }

    /* bulles d√©coratives */
    .bubble {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, .22);
      pointer-events: none;
      z-index: 0;
      box-shadow: 0 3px 8px rgba(10, 127, 90, .08);
      border: 1px solid rgba(255, 255, 255, .22);
      filter: blur(.2px);
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Bandeau bas */
    .footer-band {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      min-height: clamp(90px, var(--footer-depth), 320px);
      background:
        linear-gradient(120deg,
          #0A7F5A 0%,
          rgba(8, 140, 106, .92) 60%,
          rgba(8, 140, 106, 0) 100%),
        #0A7F5A;
      color: #fff;
      padding: clamp(14px, calc(var(--footer-depth) * 0.25), 38px) 24px clamp(20px, calc(var(--footer-depth) * 0.45), 58px);
      display: flex;
      flex-direction: column;
      gap: 6px;
      clip-path: polygon(0 var(--footer-notch), 100% 0, 100% 100%, 0 100%);
      transition: .2s ease;
      backdrop-filter: blur(1px);
      isolation: isolate;
      z-index: 12;
      transform: translate(var(--footer-shift-x, 0px), var(--footer-shift-y, 0px));
    }

    .footer-band::before {
      content: "";
      position: absolute;
      inset: -24px;
      background:
        linear-gradient(120deg,
          rgba(8, 140, 106, .7) 0%,
          rgba(8, 140, 106, .45) 55%,
          rgba(8, 140, 106, 0) 100%);
      clip-path: polygon(0 var(--footer-notch), 100% 0, 100% 100%, 0 100%);
      filter: blur(26px);
      opacity: .8;
      pointer-events: none;
      z-index: -1;
    }

    .footer-title {
      font-size: 1.25rem;
      font-weight: 700;
    }

    .footer-subtitle {
      font-size: .78rem;
      opacity: .85;
    }
  </style>
</head>

<body>

  <!-- COLONNE GAUCHE -->
  <div class="controls">
    <h2>Arri√®re-plan</h2>
    <div class="bg-mode">
      <label class="bg-mode-option"><input type="radio" name="bgMode" value="solid" />Couleur unie</label>
      <input type="color" id="solidBgColor" value="#eaf7f1" />

      <label class="bg-mode-option"><input type="radio" name="bgMode" value="image" />Image mod√®le</label>
      <input type="file" id="bgImageInput" accept="image/*" />
      <button type="button" id="bgImageClearBtn" class="secondary" disabled>Retirer l'image</button>

      <label class="bg-mode-option"><input type="radio" name="bgMode" value="generated" checked />Fond g√©n√©r√©</label>
      <select id="bgStyleSelect">
        <option value="bubbles">Bulles</option>
        <option value="waves">Ondes</option>
        <option value="dots">Pointill√©</option>
        <option value="cross">Motif croix</option>
      </select>

      <div class="palette-choice">
        <label><input type="radio" name="bgPaletteMode" value="logo" checked />Palette du logo</label>
        <label><input type="radio" name="bgPaletteMode" value="custom" />D√©grad√© personnalis√©</label>
      </div>
      <div class="custom-palette-fields" id="customPaletteFields">
        <input type="color" id="customColorA" value="#0A7F5A" />
        <input type="color" id="customColorB" value="#A4D4AE" />
      </div>
      <button type="button" id="bgRandomBtn" class="secondary">Al√©atoire</button>
    </div>

    <h2>Texte & Style</h2>
    <p class="editor-hint">Cliquez directement sur les textes de l'affiche pour les modifier. Utilisez les r√©glages
      ci-dessous pour ajuster la police, la taille ou la couleur du bloc actuellement s√©lectionn√©.</p>
    <div class="editor-status" id="editorStatus">S√©lectionnez un bloc de texte.</div>
    <div class="style-panel">
      <label for="fontFamilySelect">Police</label>
      <select id="fontFamilySelect">
        <option value="Poppins">Poppins</option>
        <option value="Playfair Display">Playfair Display</option>
        <option value="Montserrat">Montserrat</option>
        <option value="Source Serif Pro">Source Serif Pro</option>
        <option value="Raleway">Raleway</option>
      </select>

      <label for="fontSizeRange">Taille <span id="fontSizeValue">24px</span></label>
      <input type="range" id="fontSizeRange" min="14" max="64" value="24" />

      <label for="fontColorInput">Couleur</label>
      <input type="color" id="fontColorInput" value="#0a7f5a" />
    </div>
  </div>

  <!-- PREVIEW CENTRE -->
  <div class="preview-container">
    <div class="affiche" id="affiche">
      <div id="bgLayer"></div>
      <div class="header-left">
        <p class="promo-title" id="afficheTitle" data-editable="header-title" data-label="Titre promo"
          contenteditable="true" spellcheck="false">Promo d'automne - Vitamine D</p>
        <p class="promo-date" id="afficheDate" data-editable="header-date" data-label="Date/accroche"
          contenteditable="true" spellcheck="false">Du 1er au 15 novembre</p>
      </div>
      <button type="button" class="drag-handle-star header-star" id="headerDragHandle"
        aria-label="D√©placer le texte du bandeau haut">‚ú∂</button>

      <div class="logo" id="afficheLogo"><span class="placeholder">logo</span></div>
      <div class="gommette" id="afficheBadge"><span id="afficheBadgeText" data-editable="badge"
          data-label="Texte gommette" contenteditable="true" spellcheck="false">-20%</span></div>
      <div class="product-image" id="afficheProduct">
        <div class="product-placeholder">Photo du produit<br />ici</div>
      </div>

      <div class="footer-band">
        <div class="footer-title" id="afficheProductName" data-editable="footer-title" data-label="Titre bas"
          contenteditable="true" spellcheck="false">Vitamine D3 Senior 1000 UI</div>
        <div class="footer-subtitle" id="afficheProductSubtitle" data-editable="footer-subtitle"
          data-label="Sous-titre bas" contenteditable="true" spellcheck="false">Demandez conseil √† votre pharmacien
        </div>
      </div>
      <button type="button" class="drag-handle-star footer-star" id="footerDragHandle"
        aria-label="D√©placer le texte du bandeau bas">‚ú∂</button>
    </div>
  </div>

  <!-- PANNEAU DROIT : Cr√©ation & Contr√¥les (croix OK) -->
  <div class="controls controls-right">
    <h2>Cr√©ation & Contr√¥les</h2>

    <div class="control-block">
      <div class="control-title">Visuels & IA</div>

      <label>Logo pharmacie</label>
      <input id="logoInput" type="file" accept="image/*" />
      <div class="range-control">
        <label for="logoScaleRange">Taille logo <span id="logoScaleValue">100%</span></label>
        <input id="logoScaleRange" type="range" min="50" max="150" value="100" />
      </div>

      <label>Photo produit</label>
      <input id="productInput" type="file" accept="image/*" />

      <fieldset class="detourage-panel">
        <legend>ü™Ñ D√©tourage</legend>
        <div class="detourage-modes">
          <label><input type="radio" name="detourageMode" value="auto" checked />Auto (recommand√©)</label>
          <label><input type="radio" name="detourageMode" value="ia" />Forcer IA (U¬≤-Net)</label>
          <label><input type="radio" name="detourageMode" value="color" />Forcer d√©tourage Couleur</label>
        </div>
        <div class="tolerance-control" id="toleranceControl">
          <label for="toleranceRange">Tol√©rance <span id="toleranceValue">40</span></label>
          <input type="range" id="toleranceRange" min="0" max="60" value="40" />
        </div>
        <div class="model-choice">
          <span>Mod√®le IA</span>
          <label>
            <input type="radio" name="u2netModel" value="u2netp.onnx" checked />
            <span>u2netp.onnx <small>(fond uni)</small></span>
          </label>
          <label>
            <input type="radio" name="u2netModel" value="u2net.onnx" />
            <span>u2net.onnx <small>(images encombr√©es)</small></span>
          </label>
        </div>
        <p class="detourage-note">Les images restent sur votre appareil.</p>
      </fieldset>
      <div class="detourage-status" id="detourageStatus">Initialisation de l'IA‚Ä¶</div>
      <progress id="detourageProgress" class="progress" max="100" value="0" hidden></progress>
    </div>
  </div>

  <!-- SCRIPTS -->
  <script type="module">
    // --- Constantes & chemins dynamiques ---
    const DETOUR_MODE = Object.freeze({ AUTO: 'auto', IA: 'ia', COLOR: 'color' });
    const DEFAULT_MODEL_CHOICE = 'u2netp.onnx';
    const U2NET_RELEASE_URL = 'https://huggingface.co/edimah/u2net/resolve/main/u2net.onnx';
    const resolveAssetUrl = (relativePath) => new URL(relativePath, import.meta.url).href;
    const MODULE_PATH = resolveAssetUrl('../assets/js/bgremoval.mjs');
    let modelChoice = DEFAULT_MODEL_CHOICE;
    const MODEL_URLS = {
      'u2netp.onnx': resolveAssetUrl('../models/u2netp.onnx'),
      'u2net.onnx': U2NET_RELEASE_URL,
    };
    const MODEL_LABELS = {
      'u2netp.onnx': 'U¬≤-Net (fond uni)',
      'u2net.onnx': 'U¬≤-Net (images encombr√©es)',
    };
    const getModelUrl = () => MODEL_URLS[modelChoice] || MODEL_URLS[DEFAULT_MODEL_CHOICE];
    const getModelLabel = () => MODEL_LABELS[modelChoice] || modelChoice;

    // --- R√©f√©rences DOM ---
    const logoInput = document.getElementById('logoInput');
    const productInput = document.getElementById('productInput');
    const logoScaleRange = document.getElementById('logoScaleRange');
    const logoScaleValue = document.getElementById('logoScaleValue');
    const detourageStatusEl = document.getElementById('detourageStatus');
    const detourProgress = document.getElementById('detourageProgress');
    const toleranceRange = document.getElementById('toleranceRange');
    const toleranceValue = document.getElementById('toleranceValue');
    const toleranceContainer = document.getElementById('toleranceControl');
    const detourageModeInputs = document.querySelectorAll('input[name="detourageMode"]');
    const modelChoiceInputs = document.querySelectorAll('input[name="u2netModel"]');

    const affiche = document.getElementById('affiche');
    const afficheTitle = document.getElementById('afficheTitle');
    const afficheDate = document.getElementById('afficheDate');
    const afficheBadge = document.getElementById('afficheBadge');
    const afficheProductName = document.getElementById('afficheProductName');
    const afficheProductSubtitle = document.getElementById('afficheProductSubtitle');
    const afficheLogo = document.getElementById('afficheLogo');
    const afficheProduct = document.getElementById('afficheProduct');
    const bgStyleSelect = document.getElementById('bgStyleSelect');
    const bgRandomBtn = document.getElementById('bgRandomBtn');
    const bgLayer = document.getElementById('bgLayer');
    const bgModeInputs = document.querySelectorAll('input[name="bgMode"]');
    const solidBgColorInput = document.getElementById('solidBgColor');
    const bgImageInput = document.getElementById('bgImageInput');
    const bgImageClearBtn = document.getElementById('bgImageClearBtn');
    const paletteModeInputs = document.querySelectorAll('input[name="bgPaletteMode"]');
    const customPaletteFields = document.getElementById('customPaletteFields');
    const customColorAInput = document.getElementById('customColorA');
    const customColorBInput = document.getElementById('customColorB');
    const fontFamilySelect = document.getElementById('fontFamilySelect');
    const fontSizeRange = document.getElementById('fontSizeRange');
    const fontSizeValue = document.getElementById('fontSizeValue');
    const fontColorInput = document.getElementById('fontColorInput');
    const editorStatus = document.getElementById('editorStatus');
    const editableElements = document.querySelectorAll('[data-editable]');
    const headerDragHandle = document.getElementById('headerDragHandle');
    const footerDragHandle = document.getElementById('footerDragHandle');

    const root = document.documentElement;

    const DEFAULT_COLORS = ['#0A7F5A', '#4EB190', '#9FD7B8'];
    const sampleCanvas = document.createElement('canvas');
    const sampleCtx = sampleCanvas.getContext('2d');
    let brandColors = [];
    let colorThiefInstance = null;

    const state = {
      lastLogoImage: null,
      lastProductImage: null,
      lastLogoFile: null,
      lastProductFile: null,
      lastLogoDataURL: null,
      lastLogoMode: null,
      lastProductMode: null,
      logoManualColor: null,
    };

    let currentBgMode = 'solid';
    let currentPaletteMode = 'logo';
    let customPalette = [
      customColorAInput?.value || '#0A7F5A',
      customColorBInput?.value || '#A4D4AE',
    ];
    let bgImageDataURL = null;
    const baseBackground = getComputedStyle(affiche).background;

    const selectedModelInput = document.querySelector('input[name="u2netModel"]:checked');
    if (selectedModelInput?.value) {
      modelChoice = selectedModelInput.value;
    }

    // --- UI helpers ---
    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
    const clamp255 = (value) => clamp(value, 0, 255);
    const clampValue = (value, min, max) => clamp(value, min, max);

    const hexToRgb = (hex) => {
      if (!hex) return { r: 0, g: 0, b: 0 };
      let clean = hex.replace('#', '');
      if (clean.length === 3) {
        clean = clean.split('').map((c) => c + c).join('');
      }
      const intVal = parseInt(clean, 16);
      return {
        r: (intVal >> 16) & 255,
        g: (intVal >> 8) & 255,
        b: intVal & 255,
      };
    };

    const rgbArrayToHex = (arr = []) => {
      const [r = 0, g = 0, b = 0] = arr;
      const toHex = (v) => clamp255(v).toString(16).padStart(2, '0');
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    };

    const adjustColor = (hex, amount = 0) => {
      const { r, g, b } = hexToRgb(hex);
      const adjust = (channel) => clamp255(channel + amount * 255);
      return rgbArrayToHex([adjust(r), adjust(g), adjust(b)]);
    };

    const rgba = (hex, alpha = 1) => {
      const { r, g, b } = hexToRgb(hex);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    const randRange = (min, max) => Math.random() * (max - min) + min;

    const getCssVarNumber = (cssVar) => parseFloat(getComputedStyle(root).getPropertyValue(cssVar)) || 0;
    const setCssVarNumber = (cssVar, value, unit = 'px') => {
      root.style.setProperty(cssVar, `${value}${unit}`);
    };

    const clearBackgroundLayer = () => {
      if (!bgLayer) return;
      bgLayer.innerHTML = '';
      bgLayer.style.background = 'none';
      bgLayer.style.backgroundImage = 'none';
      bgLayer.style.backgroundColor = 'transparent';
    };

    const resetTextPositions = () => {
      ['--header-shift-x', '--header-shift-y', '--footer-shift-x', '--footer-shift-y'].forEach((varName) => {
        root.style.setProperty(varName, '0px');
      });
    };

    const enableTextDragMode = (enabled) => {
      if (!affiche) return;
      affiche.classList.toggle('has-model-bg', enabled);
      if (!enabled) {
        resetTextPositions();
      }
    };

    const autoAdjustBands = () => {
      const headerText = `${afficheTitle?.textContent || ''} ${afficheDate?.textContent || ''}`.trim();
      const headerChars = Math.max(headerText.length, 12);
      const headerWidth = clampValue(50 + headerChars * 0.4, 50, 95);
      const headerDepth = clampValue(110 + headerChars * 0.45, 90, 240);
      setCssVarNumber('--header-width', headerWidth, '%');
      setCssVarNumber('--header-depth', headerDepth, 'px');

      const footerText = `${afficheProductName?.textContent || ''} ${afficheProductSubtitle?.textContent || ''}`.trim();
      const footerChars = Math.max(footerText.length, 18);
      const footerDepth = clampValue(150 + footerChars * 0.3, 120, 300);
      const footerNotch = clampValue(8 + footerChars * 0.04, 4, 18);
      setCssVarNumber('--footer-depth', footerDepth, 'px');
      setCssVarNumber('--footer-notch', footerNotch, '%');
    };

    const applySolidBackground = () => {
      enableTextDragMode(false);
      if (!affiche) return;
      const color = solidBgColorInput?.value || '#eaf7f1';
      affiche.style.background = color;
      clearBackgroundLayer();
    };

    const applyGeneratedBackground = ({ forceRandom = false } = {}) => {
      enableTextDragMode(false);
      if (!affiche) return;
      affiche.style.background = baseBackground;
      regenerateBackground({ forceRandom });
    };

    const applyImageBackground = (dataURL) => {
      if (!affiche || !dataURL) return;
      affiche.style.background = `url(${dataURL}) center/cover no-repeat`;
      clearBackgroundLayer();
      enableTextDragMode(true);
      bgImageClearBtn?.removeAttribute('disabled');
    };

    const syncBackgroundControls = () => {
      const isGenerated = currentBgMode === 'generated';
      if (bgStyleSelect) bgStyleSelect.disabled = !isGenerated;
      if (solidBgColorInput) solidBgColorInput.disabled = currentBgMode !== 'solid';
      if (bgImageInput) bgImageInput.disabled = currentBgMode !== 'image';
      paletteModeInputs.forEach((radio) => {
        radio.disabled = !isGenerated;
      });
      const showCustom = isGenerated && currentPaletteMode === 'custom';
      if (customPaletteFields) {
        customPaletteFields.classList.toggle('is-visible', showCustom);
      }
      if (customColorAInput) customColorAInput.disabled = !showCustom;
      if (customColorBInput) customColorBInput.disabled = !showCustom;
      if (bgRandomBtn) bgRandomBtn.disabled = !isGenerated;
      if (bgImageClearBtn) {
        if (bgImageDataURL) {
          bgImageClearBtn.removeAttribute('disabled');
        } else {
          bgImageClearBtn.setAttribute('disabled', 'disabled');
        }
      }
    };

    const setBackgroundMode = (mode, options = {}) => {
      currentBgMode = mode;
      if (mode === 'solid') {
        applySolidBackground();
      } else if (mode === 'image') {
        if (bgImageDataURL) {
          applyImageBackground(bgImageDataURL);
        } else {
          enableTextDragMode(false);
          affiche.style.background = baseBackground;
          clearBackgroundLayer();
        }
      } else {
        applyGeneratedBackground(options);
      }
      syncBackgroundControls();
    };

    bgModeInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (input.checked) {
          setBackgroundMode(input.value);
        }
      });
    });

    solidBgColorInput?.addEventListener('input', () => {
      if (currentBgMode === 'solid') applySolidBackground();
    });

    const updateCustomPalette = () => {
      customPalette = [
        customColorAInput?.value || '#0A7F5A',
        customColorBInput?.value || '#A4D4AE',
      ];
      if (currentBgMode === 'generated' && currentPaletteMode === 'custom') {
        regenerateBackground();
      }
    };

    customColorAInput?.addEventListener('input', updateCustomPalette);
    customColorBInput?.addEventListener('input', updateCustomPalette);

    paletteModeInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (!input.checked) return;
        currentPaletteMode = input.value;
        syncBackgroundControls();
        if (currentBgMode === 'generated') regenerateBackground();
      });
    });

    bgImageInput?.addEventListener('change', async () => {
      const file = bgImageInput.files?.[0];
      if (!file) return;
      const dataURL = await readFileAsDataURL(file);
      bgImageDataURL = dataURL;
      const imageRadio = Array.from(bgModeInputs).find((input) => input.value === 'image');
      if (imageRadio) imageRadio.checked = true;
      setBackgroundMode('image');
    });

    bgImageClearBtn?.addEventListener('click', () => {
      bgImageDataURL = null;
      if (bgImageInput) bgImageInput.value = '';
      bgImageClearBtn.setAttribute('disabled', 'disabled');
      if (currentBgMode === 'image') {
        const solidRadio = Array.from(bgModeInputs).find((input) => input.value === 'solid');
        if (solidRadio) solidRadio.checked = true;
        setBackgroundMode('solid');
      }
    });


    const FONT_OPTIONS = ['Poppins', 'Playfair Display', 'Montserrat', 'Source Serif Pro', 'Raleway'];

    const rgbStringToHex = (color) => {
      const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      if (!match) return '#000000';
      return `#${match.slice(1, 4).map((val) => {
        const hex = parseInt(val, 10).toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
      }).join('')}`;
    };

    let activeEditable = null;

    const syncToolbarWithElement = (element) => {
      if (!element) return;
      const styles = window.getComputedStyle(element);
      const family = FONT_OPTIONS.find((font) => styles.fontFamily.toLowerCase().includes(font.toLowerCase())) || FONT_OPTIONS[0];
      if (fontFamilySelect) fontFamilySelect.value = family;
      const size = clampValue(parseInt(styles.fontSize, 10) || 24, 14, 64);
      if (fontSizeRange) {
        fontSizeRange.value = size;
        if (fontSizeValue) fontSizeValue.textContent = `${size}px`;
      }
      if (fontColorInput) fontColorInput.value = rgbStringToHex(styles.color);
    };

    const setActiveEditable = (element) => {
      if (activeEditable === element) return;
      if (activeEditable) activeEditable.classList.remove('is-editing');
      activeEditable = element;
      if (activeEditable) {
        activeEditable.classList.add('is-editing');
        if (editorStatus) editorStatus.textContent = activeEditable.dataset.label || 'Bloc s√©lectionn√©';
        syncToolbarWithElement(activeEditable);
      } else if (editorStatus) {
        editorStatus.textContent = 'S√©lectionnez un bloc de texte.';
      }
    };

    const clearActiveEditable = () => {
      if (activeEditable) {
        activeEditable.classList.remove('is-editing');
      }
      activeEditable = null;
      if (editorStatus) editorStatus.textContent = 'S√©lectionnez un bloc de texte.';
    };

    editableElements.forEach((el) => {
      el.setAttribute('contenteditable', 'true');
      el.setAttribute('spellcheck', 'false');
      el.addEventListener('focus', () => setActiveEditable(el));
      el.addEventListener('click', (event) => {
        setActiveEditable(el);
        event.stopPropagation();
      });
      el.addEventListener('input', () => {
        autoAdjustBands();
      });
    });

    document.addEventListener('click', (event) => {
      if (!event.target.closest('[data-editable]') && !event.target.closest('.style-panel')) {
        clearActiveEditable();
      }
    });

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        clearActiveEditable();
      }
    });

    fontFamilySelect?.addEventListener('change', () => {
      if (!activeEditable) return;
      activeEditable.style.fontFamily = fontFamilySelect.value;
    });

    fontSizeRange?.addEventListener('input', () => {
      if (!fontSizeValue) return;
      fontSizeValue.textContent = `${fontSizeRange.value}px`;
      if (!activeEditable) return;
      activeEditable.style.fontSize = `${fontSizeRange.value}px`;
      autoAdjustBands();
    });

    fontColorInput?.addEventListener('input', () => {
      if (!activeEditable) return;
      activeEditable.style.color = fontColorInput.value;
    });

    const getToleranceValue = () => Number(toleranceRange?.value || 40);

    const setToleranceVisibility = (visible) => {
      if (!toleranceContainer) return;
      toleranceContainer.classList.toggle('is-visible', Boolean(visible));
    };
    setToleranceVisibility(false);

    const updateToleranceLabel = () => {
      if (toleranceValue) toleranceValue.textContent = getToleranceValue();
    };
    updateToleranceLabel();
    if (toleranceRange) {
      toleranceRange.addEventListener('input', async () => {
        updateToleranceLabel();
        await rerunColorIfNeeded();
      });
    }

    const resetDetourProgress = () => {
      if (!detourProgress) return;
      detourProgress.hidden = true;
      detourProgress.max = 100;
      detourProgress.value = 0;
      detourProgress.setAttribute('value', 0);
    };

    const handleModelDownloadProgress = (info) => {
      if (!detourProgress) return;
      const { percent = 0, total = 0, fromCache = false } = info ?? {};
      const label = getModelLabel();
      const completedDownload = total && percent >= 100 && !fromCache;

      if (fromCache) {
        resetDetourProgress();
        setDetourageStatus(`Mod√®le ${label} d√©j√† pr√™t (cache).`, 'idle');
        return;
      }

      if (completedDownload) {
        resetDetourProgress();
        setDetourageStatus(`T√©l√©chargement termin√©. Initialisation du mod√®le ${label}‚Ä¶`, 'loading');
        return;
      }

      detourProgress.hidden = false;
      if (total) {
        detourProgress.max = 100;
        detourProgress.value = percent;
        detourProgress.setAttribute('value', percent);
      } else {
        detourProgress.removeAttribute('value');
      }
      const message = total
        ? `T√©l√©chargement du mod√®le ${label}‚Ä¶ ${percent}%`
        : `T√©l√©chargement du mod√®le ${label}‚Ä¶`;
      setDetourageStatus(message, 'loading');
    };
    resetDetourProgress();

    const setDetourageStatus = (text, state = 'idle') => {
      if (!detourageStatusEl) return;
      detourageStatusEl.textContent = text;
      detourageStatusEl.classList.toggle('loading', state === 'loading');
      detourageStatusEl.classList.toggle('error', state === 'error');
      detourageStatusEl.classList.toggle('idle', state === 'idle');
    };
    setDetourageStatus(`Initialisation du mod√®le ${getModelLabel()}‚Ä¶`, 'loading');

    let u2netInitPromise;
    let providerLogged = false;

    const getSelectedDetourMode = () => {
      const checked = document.querySelector('input[name="detourageMode"]:checked');
      return (checked?.value || DETOUR_MODE.AUTO);
    };

    detourageModeInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (!input.checked) return;
        const wantsColor = input.value === DETOUR_MODE.COLOR;
        setToleranceVisibility(wantsColor);
      });
    });

    // --- G√©n√©rateur d'arri√®re-plan ---
    const ensureColorThief = () => {
      if (!colorThiefInstance && globalThis.ColorThief) {
        colorThiefInstance = new globalThis.ColorThief();
      }
      return colorThiefInstance;
    };

    // R√©cup√®re jusqu'√† 3 couleurs dominantes depuis le logo
    const extractBrandColors = (image) => {
      const thief = ensureColorThief();
      if (!thief || !image) {
        brandColors = [];
        return;
      }
      try {
        const palette = thief.getPalette(image, 3) || [];
        brandColors = palette.map((rgb) => rgbArrayToHex(rgb));
        if (currentBgMode === 'generated' && currentPaletteMode === 'logo') {
          regenerateBackground();
        }
      } catch (err) {
        console.warn('Impossible de r√©cup√©rer la palette du logo', err);
        brandColors = [];
      }
    };

    const getPaletteSource = () => {
      if (currentPaletteMode === 'custom') {
        return customPalette.length ? customPalette : DEFAULT_COLORS;
      }
      if (currentPaletteMode === 'logo' && brandColors.length) {
        return brandColors;
      }
      return DEFAULT_COLORS;
    };

    const shuffleArray = (arr = []) => {
      const copy = arr.slice();
      for (let i = copy.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    };

    // Assemble une palette douce avec de l√©g√®res variations al√©atoires
    const blendWithWhite = (hex, factor = 0.2) => {
      const { r, g, b } = hexToRgb(hex);
      const mix = (channel) => Math.round(channel + (255 - channel) * factor);
      return rgbArrayToHex([mix(r), mix(g), mix(b)]);
    };

    const buildPalette = (forceRandom = false) => {
      const base = getPaletteSource();
      const working = forceRandom ? shuffleArray(base) : base.slice();
      const softened = working.map((color, idx) => {
        const tinted = blendWithWhite(color, 0.15 + idx * 0.05);
        return adjustColor(tinted, (Math.random() - 0.5) * 0.08);
      });
      return softened.length ? softened : DEFAULT_COLORS;
    };

    // R√©initialise la couche d'arri√®re-plan avant une nouvelle g√©n√©ration
    const clearBgLayer = () => {
      if (!bgLayer) return;
      bgLayer.innerHTML = '';
      bgLayer.style.background = 'none';
      bgLayer.style.backgroundImage = 'none';
      bgLayer.style.backgroundColor = 'transparent';
    };

    // G√©n√®re un chemin sinuso√Ødal approximatif pour les vagues
    const wavePath = (width, height, baseY, amplitude) => {
      const segments = 5;
      const step = width / segments;
      let d = `M ${-step} ${baseY}`;
      for (let i = -1; i <= segments + 1; i += 1) {
        const x = i * step;
        const cpX1 = x + step / 3;
        const cpX2 = x + (2 * step) / 3;
        const cpY1 = baseY + Math.sin(i) * amplitude;
        const cpY2 = baseY + Math.cos(i) * amplitude * 0.8;
        const endX = x + step;
        const endY = baseY + Math.sin(i + 1) * amplitude * 0.6;
        d += ` C ${cpX1} ${cpY1} ${cpX2} ${cpY2} ${endX} ${endY}`;
      }
      d += ` L ${width} ${height} L 0 ${height} Z`;
      return d;
    };

    // Empile plusieurs vagues SVG discr√®tes
    const bgWaves = (colors) => {
      if (!bgLayer) return;
      clearBgLayer();
      const svgWidth = 600;
      const svgHeight = 800;
      let waves = '';
      for (let i = 0; i < 3; i += 1) {
        const color = colors[i % colors.length] || DEFAULT_COLORS[0];
        const baseY = 160 + i * 130 + randRange(-10, 10);
        const amplitude = 18 + i * 10;
        waves += `<path d="${wavePath(svgWidth, svgHeight, baseY, amplitude)}" fill="${rgba(color, 0.12 - i * 0.025)}" />`;
      }
      bgLayer.innerHTML = `<svg viewBox="0 0 ${svgWidth} ${svgHeight}" preserveAspectRatio="none">${waves}</svg>`;
    };

    const productSafeZone = {
      left: 140,
      right: 460,
      top: 210,
      bottom: 540,
    };

    const bubbleSizes = [70, 85, 95, 115, 135];

    const isInsideProductZone = (x, y, size) => {
      const cx = x + size / 2;
      const cy = y + size / 2;
      return (
        cx > productSafeZone.left &&
        cx < productSafeZone.right &&
        cy > productSafeZone.top &&
        cy < productSafeZone.bottom
      );
    };

    const hasOverlap = (placements, x, y, size) => {
      const cx = x + size / 2;
      const cy = y + size / 2;
      return placements.some(({ x: px, y: py, size: ps }) => {
        const pcx = px + ps / 2;
        const pcy = py + ps / 2;
        const minDist = (size + ps) / 2 + 25;
        const dist = Math.hypot(pcx - cx, pcy - cy);
        return dist < minDist;
      });
    };

    const createBubbleElement = (x, y, size, tone) => {
      const bubble = document.createElement('div');
      bubble.className = 'bubble dynamic';
      bubble.style.width = `${size}px`;
      bubble.style.height = `${size}px`;
      bubble.style.left = `${x}px`;
      bubble.style.top = `${y}px`;
      bubble.style.background = `rgba(255, 255, 255, ${tone})`;
      bubble.style.borderColor = `rgba(255, 255, 255, ${tone + 0.05})`;
      bubble.style.boxShadow = `0 3px 10px rgba(10, 127, 90, ${tone - 0.03})`;
      return bubble;
    };

    const bgBubbles = (colors) => {
      if (!bgLayer) return;
      clearBgLayer();
      const placements = [];
      const count = Math.floor(randRange(2, 6));
      let attempts = 0;
      while (placements.length < count && attempts < 80) {
        attempts += 1;
        const size = bubbleSizes[Math.floor(Math.random() * bubbleSizes.length)];
        const x = randRange(30, 600 - size - 30);
        const y = randRange(140, 800 - size - 40);
        if (isInsideProductZone(x, y, size)) continue;
        if (hasOverlap(placements, x, y, size)) continue;
        placements.push({ x, y, size });
      }
      placements.forEach(({ x, y, size }, idx) => {
        const tone = 0.12 + (idx % 3) * 0.035;
        const bubble = createBubbleElement(x, y, size, tone);
        bgLayer.appendChild(bubble);
      });
    };

    // Motif pointill√© bas√© sur des d√©grad√©s CSS
    const appendProductHalo = (intensity = 0.25) => {
      const halo = document.createElement('div');
      halo.style.position = 'absolute';
      halo.style.inset = '0';
      halo.style.background = `radial-gradient(circle at 50% 45%, rgba(255,255,255,${intensity}), transparent 55%)`;
      halo.style.pointerEvents = 'none';
      halo.style.zIndex = 0;
      bgLayer.appendChild(halo);
    };

    const bgDots = (colors) => {
      if (!bgLayer) return;
      clearBgLayer();
      const primary = colors[0] || DEFAULT_COLORS[0];
      const secondary = colors[1] || DEFAULT_COLORS[1];
      bgLayer.style.backgroundImage = `radial-gradient(${rgba(primary, 0.12)} 12%, transparent 20%), radial-gradient(${rgba(secondary, 0.08)} 10%, transparent 22%)`;
      bgLayer.style.backgroundSize = '20px 20px, 20px 20px';
      bgLayer.style.backgroundPosition = '0 0, 10px 10px';
      bgLayer.style.backgroundColor = rgba(adjustColor(primary, 0.3), 0.04);
      appendProductHalo(0.22);
    };

    // Motif croix r√©p√©t√© via pattern SVG
    const bgCross = (colors) => {
      if (!bgLayer) return;
      clearBgLayer();
      const stroke = colors[0] || DEFAULT_COLORS[0];
      const accent = colors[1] || DEFAULT_COLORS[1];
      const rotation = randRange(-12, 12).toFixed(2);
      const svg = `
        <svg viewBox="0 0 600 800" preserveAspectRatio="xMidYMid slice">
          <defs>
            <pattern id="crossPattern" width="32" height="32" patternUnits="userSpaceOnUse" patternTransform="rotate(${rotation})">
            <path d="M16 4 L16 28 M4 16 L28 16" stroke="${rgba(stroke, 0.12)}" stroke-width="1.5" stroke-linecap="round" />
            </pattern>
          </defs>
          <rect width="600" height="800" fill="url(#crossPattern)" fill-opacity="0.6" />
          <rect width="600" height="800" fill="${rgba(accent, 0.03)}" />
        </svg>`;
      bgLayer.innerHTML = svg;
      appendProductHalo(0.2);
    };

    const rendererMap = {
      bubbles: bgBubbles,
      waves: bgWaves,
      dots: bgDots,
      cross: bgCross,
    };

    const regenerateBackground = ({ forceRandom = false } = {}) => {
      if (!bgLayer || currentBgMode !== 'generated') return;
      const style = bgStyleSelect?.value || 'bubbles';
      const palette = buildPalette(forceRandom);
      const render = rendererMap[style] || bgBubbles;
      render(palette);
    };

    bgStyleSelect?.addEventListener('change', () => {
      if (currentBgMode === 'generated') regenerateBackground();
    });
    bgRandomBtn?.addEventListener('click', () => {
      if (currentBgMode !== 'generated') return;
      regenerateBackground({ forceRandom: true });
    });

    modelChoiceInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (!input.checked) return;
        if (!input.value || input.value === modelChoice) return;
        modelChoice = input.value;
        providerLogged = false;
        u2netInitPromise = null;
        resetDetourProgress();
        setDetourageStatus(`Pr√©paration du mod√®le ${getModelLabel()}‚Ä¶`, 'loading');
        ensureU2NetReady().catch(() => {
          // status already handled in ensureU2NetReady
        });
      });
    });

    // --- Module IA ---
    let initU2Net;
    let removeBgFromFile;
    try {
      ({ initU2Net, removeBgFromFile } = await import(MODULE_PATH));
    } catch (err) {
      console.error('Impossible de charger le module de d√©tourage :', err);
      setDetourageStatus('Module IA introuvable, utilisez "Couleur".', 'error');
    }

    const ensureU2NetReady = async () => {
      if (!initU2Net) {
        throw new Error('Module IA non disponible.');
      }
      if (!u2netInitPromise) {
        resetDetourProgress();
        setDetourageStatus(`Initialisation du mod√®le ${getModelLabel()}‚Ä¶`, 'loading');
        u2netInitPromise = initU2Net({
          modelUrl: getModelUrl(),
          providers: ['webgpu', 'webgl', 'wasm'],
          onProgress: handleModelDownloadProgress,
        })
          .then((session) => {
            console.log('[D√©tourage] Session U¬≤-Net initialis√©e.');
            resetDetourProgress();
            setDetourageStatus(`IA pr√™te (${getModelLabel()}) üü¢`, 'idle');
            return session;
          })
          .catch((err) => {
            console.error('initU2Net error', err);
            resetDetourProgress();
            setDetourageStatus('IA indisponible, essayez "Couleur".', 'error');
            throw err;
          });
      }
      return u2netInitPromise;
    };

    ensureU2NetReady().catch(() => {
      // Le flux Couleur reste disponible.
    });

    // --- Utilitaires g√©n√©raux ---
    const readFileAsDataURL = (file) => new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target.result);
      reader.onerror = () => reject(new Error('Lecture fichier impossible.'));
      reader.readAsDataURL(file);
    });

    const fileToImage = async (file) => {
      const dataURL = await readFileAsDataURL(file);
      const image = await new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = dataURL;
      });
      return { image, dataURL };
    };

    const loadImageFromDataURL = (dataURL) => new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = dataURL;
    });

    const injectImage = (container, dataURL) => {
      if (!container) return;
      container.innerHTML = '';
      const img = document.createElement('img');
      img.src = dataURL;
      container.appendChild(img);
      container.classList.add('has-image');
    };

    const isLikelyLogo = (file, img) => {
      if (!file || !img) return false;
      const name = (file.name || '').toLowerCase();
      if (/logo|mark/.test(name)) return true;
      return img.width < 256 || img.height < 256;
    };

    const applyUnsharpMask = (imageData) => {
      const { width, height, data } = imageData;
      const srcCopy = new Uint8ClampedArray(data);
      sampleCanvas.width = width;
      sampleCanvas.height = height;
      sampleCtx.putImageData(imageData, 0, 0);

      const blurCanvas = document.createElement('canvas');
      blurCanvas.width = width;
      blurCanvas.height = height;
      const blurCtx = blurCanvas.getContext('2d');
      if ('filter' in blurCtx) {
        blurCtx.filter = 'blur(1px)';
      }
      blurCtx.drawImage(sampleCanvas, 0, 0);
      const blurData = blurCtx.getImageData(0, 0, width, height).data;

      for (let i = 0; i < data.length; i += 4) {
        data[i] = clamp255(srcCopy[i] + 0.5 * (srcCopy[i] - blurData[i]));
        data[i + 1] = clamp255(srcCopy[i + 1] + 0.5 * (srcCopy[i + 1] - blurData[i + 1]));
        data[i + 2] = clamp255(srcCopy[i + 2] + 0.5 * (srcCopy[i + 2] - blurData[i + 2]));
      }
      return imageData;
    };

    const pickPixel = (imageData, x, y) => {
      const { width, data } = imageData;
      const idx = (y * width + x) * 4;
      return {
        r: data[idx],
        g: data[idx + 1],
        b: data[idx + 2],
      };
    };

    const applyColorKey = (imageData, keyColor, tolerance) => {
      const data = imageData.data;
      const threshold = Number.isFinite(tolerance) ? tolerance : 40;
      for (let i = 0; i < data.length; i += 4) {
        const dr = Math.abs(data[i] - keyColor.r);
        const dg = Math.abs(data[i + 1] - keyColor.g);
        const db = Math.abs(data[i + 2] - keyColor.b);
        const diff = dr + dg + db;
        data[i + 3] = diff <= threshold ? 0 : 255;
      }
    };

    const extractAlpha = (imageData) => {
      const len = imageData.width * imageData.height;
      const data = imageData.data;
      const alpha = new Float32Array(len);
      for (let i = 0; i < len; i += 1) {
        alpha[i] = data[i * 4 + 3] / 255;
      }
      return alpha;
    };

    const writeAlpha = (imageData, alpha) => {
      const len = imageData.width * imageData.height;
      const data = imageData.data;
      for (let i = 0; i < len; i += 1) {
        data[i * 4 + 3] = clamp255(Math.round(alpha[i] * 255));
      }
    };

    const dilateAlpha = (alpha, width, height) => {
      const out = new Float32Array(alpha.length);
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          let max = 0;
          for (let dy = -1; dy <= 1; dy += 1) {
            for (let dx = -1; dx <= 1; dx += 1) {
              const nx = clamp(x + dx, 0, width - 1);
              const ny = clamp(y + dy, 0, height - 1);
              max = Math.max(max, alpha[ny * width + nx]);
            }
          }
          out[y * width + x] = max;
        }
      }
      return out;
    };

    const erodeAlpha = (alpha, width, height) => {
      const out = new Float32Array(alpha.length);
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          let min = 1;
          for (let dy = -1; dy <= 1; dy += 1) {
            for (let dx = -1; dx <= 1; dx += 1) {
              const nx = clamp(x + dx, 0, width - 1);
              const ny = clamp(y + dy, 0, height - 1);
              min = Math.min(min, alpha[ny * width + nx]);
            }
          }
          out[y * width + x] = min;
        }
      }
      return out;
    };

    const blurAlpha = (alpha, width, height) => {
      const out = new Float32Array(alpha.length);
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          let acc = 0;
          let count = 0;
          for (let dy = -1; dy <= 1; dy += 1) {
            for (let dx = -1; dx <= 1; dx += 1) {
              const nx = clamp(x + dx, 0, width - 1);
              const ny = clamp(y + dy, 0, height - 1);
              acc += alpha[ny * width + nx];
              count += 1;
            }
          }
          out[y * width + x] = acc / count;
        }
      }
      return out;
    };

    const softenAlpha = (imageData) => {
      const width = imageData.width;
      const height = imageData.height;
      let alpha = extractAlpha(imageData);
      alpha = dilateAlpha(alpha, width, height);
      alpha = erodeAlpha(alpha, width, height);
      alpha = blurAlpha(alpha, width, height);
      writeAlpha(imageData, alpha);
    };

    const runColorKeyDetour = async (image, { tolerance, keyColor }) => {
      const canvas = document.createElement('canvas');
      canvas.width = image.width;
      canvas.height = image.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0);
      let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      imageData = applyUnsharpMask(imageData);
      ctx.putImageData(imageData, 0, 0);
      const working = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const sampledColor = keyColor || pickPixel(working, 0, 0);
      applyColorKey(working, sampledColor, tolerance);
      softenAlpha(working);
      ctx.putImageData(working, 0, 0);
      return { dataURL: canvas.toDataURL('image/png'), sampledColor };
    };

    const sampleColorFromOriginal = (image, ratioX, ratioY) => {
      if (!image) return null;
      sampleCanvas.width = image.width;
      sampleCanvas.height = image.height;
      sampleCtx.drawImage(image, 0, 0);
      const x = clamp(Math.round(clamp(ratioX, 0, 1) * (image.width - 1)), 0, image.width - 1);
      const y = clamp(Math.round(clamp(ratioY, 0, 1) * (image.height - 1)), 0, image.height - 1);
      const pixel = sampleCtx.getImageData(x, y, 1, 1).data;
      return { r: pixel[0], g: pixel[1], b: pixel[2] };
    };

    const isMaskFlat = async (alphaDataURL) => {
      if (!alphaDataURL) return false;
      try {
        const img = await loadImageFromDataURL(alphaDataURL);
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const { data } = ctx.getImageData(0, 0, canvas.width, canvas.height);

        let total = 0;
        let nearOpaque = 0;
        let nearTransparent = 0;
        for (let i = 0; i < data.length; i += 4) {
          const alpha = data[i];
          if (alpha >= 240) nearOpaque += 1;
          else if (alpha <= 15) nearTransparent += 1;
          total += 1;
        }
        if (!total) return true;
        const ratioOpaque = nearOpaque / total;
        const ratioTransparent = nearTransparent / total;
        return ratioOpaque > 0.995 || ratioTransparent > 0.995;
      } catch {
        return false;
      }
    };

    const smartDetour = async (file, image, requestedMode, { isLogo = false, manualKeyColor = null, tolerance = getToleranceValue() } = {}) => {
      let effectiveMode = requestedMode;
      if (effectiveMode === DETOUR_MODE.AUTO) {
        if (isLogo) {
          effectiveMode = DETOUR_MODE.COLOR;
        } else if (isLikelyLogo(file, image)) {
          effectiveMode = DETOUR_MODE.COLOR;
        } else {
          effectiveMode = DETOUR_MODE.IA;
        }
      }

      if (effectiveMode === DETOUR_MODE.IA) {
        await ensureU2NetReady();
        if (!removeBgFromFile) {
          throw new Error('removeBgFromFile indisponible.');
        }
        const result = await removeBgFromFile(file, { feather: 1.5, threshold: 0.7 });
        if (!providerLogged && result?.provider) {
          console.log(`[D√©tourage] Provider IA utilis√© : ${result.provider}`);
          providerLogged = true;
        }
        if (await isMaskFlat(result?.alphaMask)) {
          throw new Error('flat_mask');
        }
        return { dataURL: result.rgbaDataURL, modeUsed: DETOUR_MODE.IA, provider: result?.provider || 'inconnu' };
      }

      const { dataURL, sampledColor } = await runColorKeyDetour(image, {
        tolerance,
        keyColor: manualKeyColor,
      });
      return {
        dataURL,
        modeUsed: DETOUR_MODE.COLOR,
        sampledColor,
      };
    };

    async function rerunColorIfNeeded() {
      if (state.lastLogoMode === DETOUR_MODE.COLOR && state.lastLogoImage) {
        await rerunLogoColor();
      } else if (state.lastProductMode === DETOUR_MODE.COLOR && state.lastProductImage) {
        await rerunProductColor();
      }
    }

    async function rerunLogoColor() {
      if (!state.lastLogoImage || !state.lastLogoFile) return;
      setDetourageStatus('Ajustement du logo‚Ä¶', 'loading');
      try {
        const result = await smartDetour(state.lastLogoFile, state.lastLogoImage, DETOUR_MODE.COLOR, {
          isLogo: true,
          manualKeyColor: state.logoManualColor,
          tolerance: getToleranceValue(),
        });
        injectImage(afficheLogo, result.dataURL);
        state.lastLogoMode = result.modeUsed;
        setDetourageStatus('Logo √† jour ‚úÖ');
      } catch (err) {
        console.error('Erreur d√©tourage logo', err);
        setDetourageStatus('Logo non mis √† jour.', 'error');
      }
    }

    async function rerunProductColor() {
      if (!state.lastProductImage || !state.lastProductFile) return;
      setDetourageStatus('Ajustement du produit‚Ä¶', 'loading');
      try {
        const result = await smartDetour(state.lastProductFile, state.lastProductImage, DETOUR_MODE.COLOR, {
          tolerance: getToleranceValue(),
        });
        injectImage(afficheProduct, result.dataURL);
        state.lastProductMode = result.modeUsed;
        setDetourageStatus('Produit mis √† jour ‚úÖ');
      } catch (err) {
        console.error('Erreur d√©tourage produit', err);
        setDetourageStatus('Produit non mis √† jour.', 'error');
      }
    }

    // --- Gestionnaires upload ---
    const handleLogoChange = async () => {
      const file = logoInput?.files?.[0];
      if (!file) return;
      setDetourageStatus('D√©tection du logo‚Ä¶', 'loading');
      let lastDataURL;
      try {
        const { image, dataURL } = await fileToImage(file);
        state.lastLogoImage = image;
        state.lastLogoFile = file;
        state.lastLogoDataURL = dataURL;
        lastDataURL = dataURL;
        state.logoManualColor = null;
        extractBrandColors(image);

        const result = await smartDetour(file, image, getSelectedDetourMode(), { isLogo: true });
        injectImage(afficheLogo, result.dataURL);
        state.lastLogoMode = result.modeUsed;
        setToleranceVisibility(result.modeUsed === DETOUR_MODE.COLOR);
        setDetourageStatus(result.modeUsed === DETOUR_MODE.IA ? 'Logo d√©tour√© par IA ‚úÖ' : 'Logo d√©tour√© ‚úÖ');
      } catch (err) {
        console.error('Logo detour error', err);
        const isFlatMask = err?.message === 'flat_mask';
        const message = isFlatMask ? 'IA confuse sur ce logo, testez "Couleur".' : '√âchec d√©tourage logo.';
        setDetourageStatus(`${message} (affich√© avec fond)`, 'error');
        if (lastDataURL) {
          injectImage(afficheLogo, lastDataURL);
          state.lastLogoMode = null;
          setToleranceVisibility(getSelectedDetourMode() === DETOUR_MODE.COLOR);
        }
      } finally {
        regenerateBackground({ forceRandom: true });
      }
    };

    const handleProductChange = async () => {
      const file = productInput?.files?.[0];
      if (!file) return;
      setDetourageStatus('D√©tourage du produit‚Ä¶', 'loading');
      let lastDataURL;
      try {
        const { image, dataURL } = await fileToImage(file);
        state.lastProductImage = image;
        state.lastProductFile = file;
        lastDataURL = dataURL;

        const result = await smartDetour(file, image, getSelectedDetourMode());
        injectImage(afficheProduct, result.dataURL);
        state.lastProductMode = result.modeUsed;
        lastDataURL = result.dataURL;
        setToleranceVisibility(result.modeUsed === DETOUR_MODE.COLOR);
        if (result.modeUsed === DETOUR_MODE.IA) {
          setDetourageStatus(`Produit d√©tour√© par IA (${result.provider || 'IA'}) ‚úÖ`);
        } else {
          setDetourageStatus('Produit d√©tour√© (Couleur) ‚úÖ');
        }
      } catch (err) {
        console.error('Product detour error', err);
        const isFlatMask = err?.message === 'flat_mask';
        const msg = isFlatMask
          ? 'IA h√©sitante : essayez "Forcer Couleur".'
          : '√âchec IA, essayez "Forcer Couleur".';
        setDetourageStatus(`${msg} (affich√© avec fond)`, 'error');
        if (lastDataURL) {
          injectImage(afficheProduct, lastDataURL);
          state.lastProductMode = null;
          setToleranceVisibility(getSelectedDetourMode() === DETOUR_MODE.COLOR);
        }
      }
    };

    logoInput?.addEventListener('change', handleLogoChange);
    productInput?.addEventListener('change', handleProductChange);

    // Eyedropper sur le logo
    afficheLogo?.addEventListener('click', async (event) => {
      if (state.lastLogoMode !== DETOUR_MODE.COLOR || !state.lastLogoImage) return;
      const img = afficheLogo.querySelector('img');
      if (!img) return;
      const rect = img.getBoundingClientRect();
      const ratioX = (event.clientX - rect.left) / rect.width;
      const ratioY = (event.clientY - rect.top) / rect.height;
      const sampled = sampleColorFromOriginal(state.lastLogoImage, ratioX, ratioY);
      if (!sampled) return;
      state.logoManualColor = sampled;
      await rerunLogoColor();
    });

    // --- Interactions directes (drag + zoom) ---
    const setupTransformHandle = (element, {
      dxVar,
      dyVar,
      scaleVar,
      minScale = 0.5,
      maxScale = 2.5,
    }) => {
      if (!element) return;
      const state = {
        x: parseFloat(getComputedStyle(root).getPropertyValue(dxVar)) || 0,
        y: parseFloat(getComputedStyle(root).getPropertyValue(dyVar)) || 0,
        scale: parseFloat(getComputedStyle(root).getPropertyValue(scaleVar)) || 1,
      };

      const apply = () => {
        root.style.setProperty(dxVar, `${state.x}px`);
        root.style.setProperty(dyVar, `${state.y}px`);
        root.style.setProperty(scaleVar, String(state.scale));
      };
      apply();

      const activePointers = new Map();
      let primaryPointerId = null;
      let panStart = { x: state.x, y: state.y };
      let pinchStartDist = 0;
      let pinchStartScale = state.scale;

      const updateFromPointers = () => {
        if (activePointers.size === 0) {
          element.classList.remove('dragging');
          return;
        }
        if (activePointers.size === 1 && primaryPointerId) {
          const pointer = activePointers.get(primaryPointerId);
          if (!pointer) return;
          const dx = pointer.currentX - pointer.startX;
          const dy = pointer.currentY - pointer.startY;
          state.x = panStart.x + dx;
          state.y = panStart.y + dy;
          apply();
        } else if (activePointers.size >= 2) {
          const pointers = Array.from(activePointers.values());
          if (pointers.length < 2 || pinchStartDist === 0) return;
          const dist = Math.hypot(
            pointers[0].currentX - pointers[1].currentX,
            pointers[0].currentY - pointers[1].currentY,
          );
          if (!dist) return;
          state.scale = clampValue(pinchStartScale * (dist / pinchStartDist), minScale, maxScale);
          apply();
        }
      };

      const handlePointerDown = (event) => {
        if (event.target && event.target.closest('[data-editable]')) {
          return;
        }
        event.preventDefault();
        element.setPointerCapture(event.pointerId);
        activePointers.set(event.pointerId, {
          startX: event.clientX,
          startY: event.clientY,
          currentX: event.clientX,
          currentY: event.clientY,
        });
        if (primaryPointerId === null) {
          primaryPointerId = event.pointerId;
          panStart = { x: state.x, y: state.y };
        } else if (activePointers.size === 2) {
          const pointers = Array.from(activePointers.values());
          pinchStartDist = Math.hypot(
            pointers[0].currentX - pointers[1].currentX,
            pointers[0].currentY - pointers[1].currentY,
          );
          pinchStartScale = state.scale;
        }
        element.classList.add('dragging');
      };

      const handlePointerMove = (event) => {
        if (!activePointers.has(event.pointerId)) return;
        const data = activePointers.get(event.pointerId);
        data.currentX = event.clientX;
        data.currentY = event.clientY;
        updateFromPointers();
      };

      const cleanupPointer = (event) => {
        if (element.hasPointerCapture?.(event.pointerId)) {
          element.releasePointerCapture(event.pointerId);
        }
        if (activePointers.has(event.pointerId)) {
          activePointers.delete(event.pointerId);
        }
        if (primaryPointerId === event.pointerId) {
          primaryPointerId = activePointers.size ? Array.from(activePointers.keys())[0] : null;
          if (primaryPointerId) {
            const pointer = activePointers.get(primaryPointerId);
            panStart = {
              x: state.x - (pointer.currentX - pointer.startX),
              y: state.y - (pointer.currentY - pointer.startY),
            };
          }
        }
        if (activePointers.size < 2) {
          pinchStartDist = 0;
        }
        updateFromPointers();
      };

      const handleWheel = (event) => {
        event.preventDefault();
        const delta = -event.deltaY;
        const factor = delta > 0 ? 1.05 : 0.95;
        state.scale = clampValue(state.scale * factor, minScale, maxScale);
        apply();
      };

      element.addEventListener('pointerdown', handlePointerDown);
      element.addEventListener('pointermove', handlePointerMove);
      element.addEventListener('pointerup', cleanupPointer);
      element.addEventListener('pointercancel', cleanupPointer);
      element.addEventListener('wheel', handleWheel, { passive: false });
    };

    setupTransformHandle(document.getElementById('afficheProduct'), {
      dxVar: '--product-shift-x',
      dyVar: '--product-shift-y',
      scaleVar: '--product-scale',
      minScale: 0.4,
      maxScale: 2.5,
    });

    setupTransformHandle(document.getElementById('afficheBadge'), {
      dxVar: '--gommette-shift-x',
      dyVar: '--gommette-shift-y',
      scaleVar: '--gommette-scale',
      minScale: 0.5,
      maxScale: 1.8,
    });

    const setupTextDragHandle = (handle, xVar, yVar) => {
      if (!handle) return;
      let pointerId = null;
      const pointerState = {};

      const apply = (x, y) => {
        root.style.setProperty(xVar, `${x}px`);
        root.style.setProperty(yVar, `${y}px`);
      };

      const onPointerMove = (event) => {
        if (event.pointerId !== pointerId || currentBgMode !== 'image') return;
        const dx = event.clientX - pointerState.startX;
        const dy = event.clientY - pointerState.startY;
        const nextX = clampValue(pointerState.baseX + dx, -240, 240);
        const nextY = clampValue(pointerState.baseY + dy, -220, 240);
        apply(nextX, nextY);
      };

      const releasePointer = (event) => {
        if (event.pointerId !== pointerId) return;
        handle.releasePointerCapture(pointerId);
        handle.removeEventListener('pointermove', onPointerMove);
        handle.removeEventListener('pointerup', releasePointer);
        handle.removeEventListener('pointercancel', releasePointer);
        pointerId = null;
      };

      handle.addEventListener('pointerdown', (event) => {
        if (currentBgMode !== 'image') return;
        event.preventDefault();
        pointerId = event.pointerId;
        pointerState.startX = event.clientX;
        pointerState.startY = event.clientY;
        pointerState.baseX = getCssVarNumber(xVar);
        pointerState.baseY = getCssVarNumber(yVar);
        handle.setPointerCapture(pointerId);
        handle.addEventListener('pointermove', onPointerMove);
        handle.addEventListener('pointerup', releasePointer);
        handle.addEventListener('pointercancel', releasePointer);
      });
    };

    setupTextDragHandle(headerDragHandle, '--header-shift-x', '--header-shift-y');
    setupTextDragHandle(footerDragHandle, '--footer-shift-x', '--footer-shift-y');

    // --- Contr√¥les bandeaux ---
    if (logoScaleRange) {
      const applyLogoScale = (val) => {
        const pct = `${val}%`;
        const scale = (val / 100).toFixed(2);
        root.style.setProperty('--logo-scale', scale);
        if (logoScaleValue) logoScaleValue.textContent = pct;
      };
      applyLogoScale(logoScaleRange.value);
      logoScaleRange.addEventListener('input', (event) => applyLogoScale(event.target.value));
    }

    const initialBgMode = Array.from(bgModeInputs).find((input) => input.checked)?.value || 'solid';
    setBackgroundMode(initialBgMode);
    autoAdjustBands();
  </script>

</body>

</html>